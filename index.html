<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>贪吃蛇游戏</title>
  <style>
    body { margin: 0; display: flex; flex-direction: column; align-items: center; background: #111; color: #fff; font-family: sans-serif; }
    canvas { background: #333; margin-top: 20px; }
    .buttons { margin-top: 10px; display: flex; flex-wrap: wrap; justify-content: center; }
    .btn { padding: 10px 20px; margin: 5px; background: #333; color: #fff; border: none; font-size: 18px; border-radius: 8px; }
    #currentTimeDisplay { margin-top: 10px; font-size: 16px; }
    #scoreDisplay { margin-top: 5px; font-size: 20px; color: #fff; }
    #rulesContainer { margin-top: 15px; padding: 10px; border: 1px solid #555; border-radius: 5px; max-width: 500px; text-align: left; background-color: #222; }
    #rulesContainer h2 { margin-top: 0; color: #fff; text-align: center;}
    #rulesContainer h3 { margin-top: 15px; margin-bottom: 5px; color: #eee; }
    #rulesContainer ul { margin-left: 20px; padding-left: 10px; }
    #rulesContainer li { margin-bottom: 8px; line-height: 1.4; }
    #rulesContainer strong { color: #fff; }
    #rulesContainer p { margin-bottom: 10px; line-height: 1.4;}
  </style>
</head>
<body>
  <h1>贪吃蛇游戏</h1>
  <div id="currentTimeDisplay"></div>
  <div id="scoreDisplay">Current Length: 0</div> <!-- Label changed -->
  <div id="gameStatusContainer" style="margin-top: 10px; padding: 5px; border: 1px solid #444; color: #ccc; font-size: 14px;">
      <div id="targetLengthDisplay" style="margin-bottom: 3px;">Target Length: 0</div>
      <div id="roundsDisplay" style="margin-bottom: 3px;">Rounds Cleared: 0 / 5</div>
      <div id="foodThisRoundDisplay">Food This Round: 0 / 10</div>
  </div>
  <canvas id="game" width="400" height="400"></canvas>
  <div class="buttons">
    <button id="toggleRulesBtn" class="btn">Show Rules</button> <!-- Added Rules Button -->
    <button class="btn" onclick="setDirection('up')">↑</button>
    <button class="btn" onclick="setDirection('left')">←</button>
    <button class="btn" onclick="setDirection('down')">↓</button>
    <button class="btn" onclick="setDirection('right')">→</button>
    <button id="controlBtn" class="btn">Start Game</button> <!-- ID changed, text updated by JS -->
    <button id="playPauseBtn" class="btn">Play/Pause Music</button><span style="font-size: 12px; color: #aaa; margin-left: 5px;">(Music: 'background_music.mp3' needed)</span>
    <button class="btn difficulty-btn" data-level="easy" style="display: none;">Easy</button>
    <button class="btn difficulty-btn" data-level="medium" style="display: none;">Medium</button>
    <button class="btn difficulty-btn" data-level="hard" style="display: none;">Hard</button>
  </div>

  <!-- Rules Container -->
  <div id="rulesContainer" style="display: block; margin-top: 15px; padding: 10px; border: 1px solid #555; border-radius: 5px; max-width: 500px; text-align: left; background-color: #222;">
      <!-- Content will be populated by JavaScript -->
  </div>

  <!-- NOTE: "background_music.mp3" is a placeholder. Replace with a valid audio file path for music to play. -->
  <audio id="bgMusic" src="background_music.mp3" loop></audio>

  <!-- Scripts will be loaded here -->
  <script src="food.js"></script>
  <script src="snake.js"></script>
  <script src="game.js"></script>

  <script>
    // Essential global variables for canvas and game setup
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    const box = 20; // Size of each game grid box
    const rows = canvas.width / box; // Number of rows/columns in the grid

    // UI Elements & Event Listeners specific to index.html
    const bgMusic = document.getElementById("bgMusic");
    const playPauseBtn = document.getElementById("playPauseBtn");
    const difficultyButtons = document.querySelectorAll(".difficulty-btn");
    const controlBtn = document.getElementById("controlBtn"); // Updated ID
    const currentTimeDisplay = document.getElementById("currentTimeDisplay");
    const toggleRulesBtn = document.getElementById('toggleRulesBtn');
    const rulesContainer = document.getElementById('rulesContainer');

    function updateControlBtnText() {
        // Assumes controlBtn, gameStarted, gameOver, isPaused are accessible
        if (!gameStarted) {
            controlBtn.textContent = 'Start Game';
        } else if (gameOver) {
            controlBtn.textContent = 'Restart Game';
        } else if (isPaused) {
            controlBtn.textContent = 'Resume Game';
        } else {
            controlBtn.textContent = 'Pause Game';
        }
    }

    // Initialize food and draw initial game screen (start message)
    // food.js and game.js functions are now globally available.
    document.addEventListener('DOMContentLoaded', () => {
        drawGame(); // Call from game.js to draw the initial "Press Start Game" screen.
        updateControlBtnText(); // Set initial text for controlBtn

        // Populate Rules
        rulesContainer.innerHTML = `
            <h2>Welcome to Snake!</h2>

            <h3>Game Mode: Target Length</h3>
            <p>The primary goal in this mode is to complete <strong>${maxRoundsPerGame} rounds</strong> by growing your snake to a target length in each round. You have a limited number of food items per round (<strong>${maxFoodPerRound}</strong>) to reach the target length. Traditional score is replaced by your snake's current length.</p>

            <h3>Objective (Target Length Mode):</h3>
            <p>In each round, grow your snake to the displayed "Target Length" by eating food. You must do this before consuming all "Food This Round". Complete all rounds to win!</p>

            <h3>Standard Objective (If not playing Target Length Mode / For reference):</h3>
            <p>Control the snake to eat food, grow longer, and achieve the highest score! Avoid colliding with the walls or the snake's own body.</p>

            <h3>Controls:</h3>
            <ul>
                <li><strong>Desktop:</strong>
                    <ul>
                        <li>Arrow Keys (Up, Down, Left, Right): Control snake direction.</li>
                        <li>Spacebar: Pause / Resume game.</li>
                    </ul>
                </li>
                <li><strong>Mobile:</strong>
                    <ul>
                        <li>Swipe (Up, Down, Left, Right) on the game area: Control snake direction.</li>
                        <li>Double-Tap on the game area: Pause / Resume game. If game is over or not started, it will Start/Restart.</li>
                    </ul>
                </li>
            </ul>

            <h3>Scoring & Rounds (Target Length Mode):</h3>
            <ul>
                <li><strong>Current Length:</strong> Your snake's current length is displayed. This is your "score" for the round.</li>
                <li><strong>Target Length:</strong> The length your snake needs to reach to complete the current round.</li>
                <li><strong>Food This Round:</strong> Shows how many food items you've eaten out of the maximum allowed for the current round. If this limit is reached before achieving the Target Length, the game is over.</li>
                <li><strong>Rounds Cleared:</strong> Tracks how many rounds you've successfully completed out of the total.</li>
            </ul>

            <h3>Difficulty Levels:</h3>
            <p>Choose from Easy, Medium, or Hard before starting or during gameplay. Higher difficulty means a faster snake!</p>

            <h3>Food Types & Effects:</h3>
            <ul>
                <li><strong>Regular Food:</strong> Effect: Snake grows by one segment. (Base score: +1, but primary goal is length).</li>
                <li><strong>Apple (Yellow):</strong> Effect: Score bonus (less relevant in Target Length mode, but still gives +5 to traditional score if tracked). Snake temporarily changes color.</li>
                <li><strong>Banana (Orange):</strong> Effect: Temporary speed boost. (Base score: +2).</li>
                <li><strong>Obstacle (Gray):</strong> Effect: Game Over!</li>
                <li><strong>Red Block (Dark Red):</strong> Effect (Length): Doubles snake's current length. Effect (Width/Fattening): Eat 2 consecutively for width increase (up to a maximum width). Eating any other food type resets the consecutive counter. (Base score: +2).</li>
                <li><strong>Green Block (Dark Green):</strong> Effect: Halves snake's length (if > 2 segments). (Base score: +2).</li>
            </ul>

            <p>Have fun reaching the targets!</p>
        `; // Removed "External Button" section as it's not implemented yet.

        // Rules Toggle Button Listener
        toggleRulesBtn.addEventListener('click', () => {
            if (rulesContainer.style.display === 'none' || rulesContainer.style.display === '') {
                rulesContainer.style.display = 'block';
                toggleRulesBtn.textContent = 'Hide Rules';
            } else {
                rulesContainer.style.display = 'none';
                toggleRulesBtn.textContent = 'Show Rules';
            }
        });

        // Update button text based on initial rules visibility
        if (rulesContainer.style.display === 'block') {
            toggleRulesBtn.textContent = 'Hide Rules';
        } else {
            toggleRulesBtn.textContent = 'Show Rules';
        }
    });

    // Event Listener for the new controlBtn (replaces old startGameBtn listener)
    controlBtn.addEventListener('click', function() {
        if (!gameStarted) {
            initGame(); // from game.js
            difficultyButtons.forEach(btn => btn.style.display = 'inline-block'); // Show difficulty buttons
        } else if (gameOver) {
            initGame(); // from game.js
            difficultyButtons.forEach(btn => btn.style.display = 'inline-block'); // Show difficulty buttons
        } else {
            togglePauseGame(); // from game.js
        }
        // updateControlBtnText() is called by initGame/togglePauseGame in game.js
    });

    // Event Listener for Keyboard Controls
    document.addEventListener("keydown", e => {
      if (e.key === " ") {
        // Pause logic is now within togglePauseGame in game.js
        togglePauseGame();
        e.preventDefault();
      } else if (gameStarted && !isPaused) {
        // Direction change logic is now within changeDirection in snake.js
        if (e.key === "ArrowUp") { changeDirection('up'); }
        else if (e.key === "ArrowDown") { changeDirection('down'); }
        else if (e.key === "ArrowLeft") { changeDirection('left'); }
        else if (e.key === "ArrowRight") { changeDirection('right'); }
      }
    });

    // Event Listener for Touchscreen Direction Buttons
    // This function is called by onclick attributes in HTML
    function setDirection(direction) {
      if (gameStarted && !isPaused) {
        changeDirection(direction); // from snake.js
      }
    }

    // Event Listeners for Difficulty Buttons
    difficultyButtons.forEach(button => {
      button.addEventListener("click", () => {
        setGameDifficulty(button.dataset.level); // from game.js
      });
    });

    // Music Play/Pause Button
    playPauseBtn.addEventListener("click", () => {
      if (bgMusic.paused) {
        bgMusic.play();
        playPauseBtn.textContent = "Pause Music";
      } else {
        bgMusic.pause();
        playPauseBtn.textContent = "Play Music";
      }
    });

    // Current Time Display
    function updateTime() {
      const now = new Date();
      const hours = String(now.getHours()).padStart(2, '0');
      const minutes = String(now.getMinutes()).padStart(2, '0');
      const seconds = String(now.getSeconds()).padStart(2, '0');
      currentTimeDisplay.innerHTML = `${hours}:${minutes}:${seconds}`;
    }
    updateTime(); // Initial call
    setInterval(updateTime, 1000); // Update every second

    // Swipe Controls for Mobile
    let touchStartX = 0;
    let touchStartY = 0;
    let touchEndX = 0;
    let touchEndY = 0;
    const minSwipeDistance = 30; // Minimum distance for a swipe to be registered
    let lastTapTime = 0;
    const doubleTapDelay = 300; // Milliseconds
    const tapThreshold = 10; // Max pixels to move for it to be considered a tap

    canvas.addEventListener('touchstart', function(e) {
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
        // Using preventDefault here might interfere with double tap,
        // as it can prevent subsequent touchend in some cases if not handled carefully.
        // Let's manage preventDefault in touchend conditionally.
    }, false);

    canvas.addEventListener('touchmove', function(e) {
        // If there's enough movement, prevent default to avoid scrolling during a swipe.
        if (gameStarted && !isPaused) { // Only consider preventing scroll if game is active
            const currentX = e.touches[0].clientX;
            const currentY = e.touches[0].clientY;
            const diffX = currentX - touchStartX;
            const diffY = currentY - touchStartY;
            // If swipe is predominantly horizontal or vertical and exceeds a small threshold
            if (Math.abs(diffX) > tapThreshold || Math.abs(diffY) > tapThreshold) {
                // e.preventDefault(); // This can be too aggressive, let's test without first.
            }
        }
    }, false);

    canvas.addEventListener('touchend', function(e) {
        touchEndX = e.changedTouches[0].clientX;
        touchEndY = e.changedTouches[0].clientY;

        const diffX = touchEndX - touchStartX;
        const diffY = touchEndY - touchStartY;
        const currentTime = new Date().getTime();
        const tapTimeDifference = currentTime - lastTapTime;

        // Check if it's a tap (minimal movement)
        if (Math.abs(diffX) < tapThreshold && Math.abs(diffY) < tapThreshold) {
            e.preventDefault(); // Prevent default actions for taps (like zoom)
            if (tapTimeDifference < doubleTapDelay && tapTimeDifference > 0) {
                // Double tap
                if (gameStarted && !gameOver) {
                    togglePauseGame(); // Pause/resume active game
                } else {
                    // If game not started, or is over, double tap acts like "Start Game"
                    // Need to ensure UI elements like start button are handled correctly by initGame
                    const startGameButton = document.getElementById('startGameBtn');
                    if(startGameButton) startGameButton.style.display = 'none'; // Hide if visible
                    difficultyButtons.forEach(btn => btn.style.display = 'inline-block'); // Show
                    initGame();
                }
                lastTapTime = 0; // Reset lastTapTime to prevent triple tap from acting as double
            } else {
                // Single tap
                lastTapTime = currentTime;
            }
        } else { // Else, it's a swipe
            if (!gameStarted || isPaused) return; // Only process swipes if game is active and not paused

            if (Math.abs(diffX) > Math.abs(diffY)) { // Horizontal swipe
                if (diffX > minSwipeDistance) {
                    changeDirection('right');
                } else if (diffX < -minSwipeDistance) {
                    changeDirection('left');
                }
            } else if (Math.abs(diffY) > Math.abs(diffX)) { // Vertical swipe
                if (diffY > minSwipeDistance) {
                    changeDirection('down');
                } else if (diffY < -minSwipeDistance) {
                    changeDirection('up');
                }
            }
            // Consider adding e.preventDefault() here for swipes if page scrolling is an issue.
        }
    }, false);

    // Canvas click/tap to start game
    canvas.addEventListener('click', function() {
        if (!gameStarted) { // gameStarted is global from game.js
            initGame(); // from game.js
            difficultyButtons.forEach(btn => btn.style.display = 'inline-block'); // Show difficulty buttons
            // initGame will call updateControlBtnText via game.js
        }
    });

    // Ensure difficulty buttons are hidden initially, shown by initGame
    // This should be done once, perhaps after defining difficultyButtons or in DOMContentLoaded
    // For safety, let's ensure they are hidden on script load if not already by HTML.
    // However, the HTML already sets them to display:none. This line is redundant but harmless.
    // difficultyButtons.forEach(btn => btn.style.display = 'none');


  </script>
</body>
</html>
