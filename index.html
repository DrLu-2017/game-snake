<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>贪吃蛇游戏</title>
  <style>
    body { margin: 0; display: flex; flex-direction: column; align-items: center; background: #111; color: #fff; font-family: sans-serif; }
    canvas { background: #333; margin-top: 20px; }
    .buttons { margin-top: 10px; display: flex; flex-wrap: wrap; justify-content: center; }
    .btn { padding: 10px 20px; margin: 5px; background: #333; color: #fff; border: none; font-size: 18px; border-radius: 8px; }
    #currentTimeDisplay { margin-top: 10px; font-size: 16px; }
    #scoreDisplay { margin-top: 5px; font-size: 20px; color: #fff; }
    #rulesContainer { margin-top: 15px; padding: 10px; border: 1px solid #555; border-radius: 5px; max-width: 500px; text-align: left; background-color: #222; }
    #rulesContainer h2 { margin-top: 0; color: #fff; text-align: center;}
    #rulesContainer h3 { margin-top: 15px; margin-bottom: 5px; color: #eee; }
    #rulesContainer ul { margin-left: 20px; padding-left: 10px; }
    #rulesContainer li { margin-bottom: 8px; line-height: 1.4; }
    #rulesContainer strong { color: #fff; }
    #rulesContainer p { margin-bottom: 10px; line-height: 1.4;}
  </style>
</head>
<body>
  <h1>贪吃蛇游戏</h1>
  <div id="currentTimeDisplay"></div>

  <!-- Player 1 Status -->
  <div id="p1StatusContainer" style="margin-top: 10px; padding: 5px; border: 1px solid #444; color: #ccc; font-size: 14px; width: 200px; text-align: center; margin-right: 5px;">
      <h4>Player 1 (Green)</h4>
      <div id="p1CurrentLengthDisplay">Current Length: 0</div>
      <div id="p1TargetLengthDisplay" style="margin-bottom: 3px;">Target Length: 0</div>
      <div id="p1RoundsDisplay" style="margin-bottom: 3px;">Rounds Cleared: 0 / 5</div>
      <div id="p1FoodThisRoundDisplay">Food This Round: 0 / 10</div>
      <div id="p1GameOverDisplay" style="color: red; display: none; font-weight: bold;">GAME OVER</div>
  </div>

  <!-- Player 2 Status -->
  <div id="p2StatusContainer" style="margin-top: 10px; padding: 5px; border: 1px solid #444; color: #ccc; font-size: 14px; width: 200px; text-align: center; margin-left: 5px;">
      <h4>Player 2 (Blue)</h4>
      <div id="p2CurrentLengthDisplay">Current Length: 0</div>
      <div id="p2TargetLengthDisplay" style="margin-bottom: 3px;">Target Length: 0</div>
      <div id="p2RoundsDisplay" style="margin-bottom: 3px;">Rounds Cleared: 0 / 5</div>
      <div id="p2FoodThisRoundDisplay">Food This Round: 0 / 10</div>
      <div id="p2GameOverDisplay" style="color: red; display: none; font-weight: bold;">GAME OVER</div>
  </div>

  <!-- ScoreDisplay is removed as it's incorporated into P1 status. gameStatusContainer is replaced by P1 & P2 containers. -->
  <!-- <div id="scoreDisplay">Current Length: 0</div> -->
  <!-- <div id="gameStatusContainer" style="margin-top: 10px; padding: 5px; border: 1px solid #444; color: #ccc; font-size: 14px;">
      <div id="targetLengthDisplay" style="margin-bottom: 3px;">Target Length: 0</div>
      <div id="roundsDisplay" style="margin-bottom: 3px;">Rounds Cleared: 0 / 5</div>
      <div id="foodThisRoundDisplay">Food This Round: 0 / 10</div>
  </div> -->

  <canvas id="game" width="400" height="400"></canvas>
  <div class="buttons">
    <button id="toggleRulesBtn" class="btn">Show Rules</button> <!-- Added Rules Button -->
    <button class="btn" onclick="setDirection('up')">↑</button>
    <button class="btn" onclick="setDirection('left')">←</button>
    <button class="btn" onclick="setDirection('down')">↓</button>
    <button class="btn" onclick="setDirection('right')">→</button>
    <button id="controlBtn" class="btn">Start Game</button> <!-- ID changed, text updated by JS -->
    <button id="playPauseBtn" class="btn">Play/Pause Music</button><span style="font-size: 12px; color: #aaa; margin-left: 5px;">(Music: 'background_music.mp3' needed)</span>
    <button class="btn difficulty-btn" data-level="easy" style="display: none;">Easy</button>
    <button class="btn difficulty-btn" data-level="medium" style="display: none;">Medium</button>
    <button class="btn difficulty-btn" data-level="hard" style="display: none;">Hard</button>
  </div>

  <!-- Rules Container -->
  <div id="rulesContainer" style="display: block; margin-top: 15px; padding: 10px; border: 1px solid #555; border-radius: 5px; max-width: 500px; text-align: left; background-color: #222;">
      <!-- Content will be populated by JavaScript -->
  </div>

  <!-- NOTE: "background_music.mp3" is a placeholder. Replace with a valid audio file path for music to play. -->
  <audio id="bgMusic" src="background_music.mp3" loop></audio>

  <!-- Define global canvas/grid vars BEFORE loading external scripts that might use them -->
  <script>
    // Essential global variables for canvas and game setup
    // These must be defined before food.js, snake.js, game.js are loaded if they use these at parse time.
    // The canvas element must exist in the DOM before this script runs.
    // This script block should be placed after the canvas element, or within DOMContentLoaded.
    // For simplicity, assuming this entire script block (including this part) is at the end of <body>.
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    const box = 10; // New cell size
    const rows = canvas.height / box; // Number of rows (Y dimension)
    const cols = canvas.width / box;  // Number of columns (X dimension)
    console.log("[DEBUG_STARTUP] index.html: Initial globals defined. Box: " + box + ", Rows: " + rows + ", Cols: " + cols);
  </script>

  <!-- External game logic scripts -->
  <script src="food.js"></script>
  <script src="snake.js"></script>
  <script src="game.js"></script>

  <!-- Main inline script for UI, event listeners, and starting the game -->
  <script>
    // UI Elements & Event Listeners specific to index.html
    // Note: canvas, ctx, box, rows, cols are already defined in the script block above.
    const bgMusic = document.getElementById("bgMusic");
    const playPauseBtn = document.getElementById("playPauseBtn");
    const difficultyButtons = document.querySelectorAll(".difficulty-btn");
    const controlBtn = document.getElementById("controlBtn"); // Updated ID
    // const scoreDisplay = document.getElementById("scoreDisplay"); // Replaced by p1CurrentLengthDisplay etc.
    const toggleRulesBtn = document.getElementById('toggleRulesBtn');
    const rulesContainer = document.getElementById('rulesContainer');

    function updateControlBtnText() {
        // Assumes controlBtn, gameStarted, gameOver, isPaused are accessible (gameOver is master)
        if (!gameStarted) {
            controlBtn.textContent = 'Start Game';
        } else if (gameOver) { // Master game over
            controlBtn.textContent = 'Restart Game';
        } else if (isPaused) {
            controlBtn.textContent = 'Resume Game';
        } else {
            controlBtn.textContent = 'Pause Game';
        }
    }

    // Initialize food and draw initial game screen (start message)
    // food.js and game.js functions are now globally available.
    document.addEventListener('DOMContentLoaded', () => {
        console.log("[DEBUG_STARTUP] index.html: DOMContentLoaded: Initial drawGame call preparing to show start screen.");
        drawGame(); // Call from game.js to draw the initial "Press Start Game" screen.
        updateControlBtnText(); // Set initial text for controlBtn
        updateGameStatusDisplay(); // Initialize P1/P2 status displays

        // Populate Rules
        rulesContainer.innerHTML = `
            <h2>Welcome to Snake!</h2>

            <h3>Game Mode: Two-Player Target Length</h3>
            <p>Compete with a friend or play cooperatively! Each player controls their own snake and tries to complete <strong>${maxRoundsPerGame} rounds</strong>. In each round, players must grow their snake to a randomly assigned target length by eating food. Each player has a limit of <strong>${maxFoodPerRound}</strong> food items per round to reach their target. Your snake's current length is your primary score for the round.</p>

            <h3>Controls:</h3>
            <ul>
                <li><strong>Player 1 (Green Snake):</strong>
                    <ul>
                        <li>Arrow Keys (Up, Down, Left, Right): Control snake direction.</li>
                    </ul>
                </li>
                <li><strong>Player 2 (Blue Snake):</strong>
                    <ul>
                        <li>W, A, S, D Keys: Control snake direction (W=Up, A=Left, S=Down, D=Right).</li>
                    </ul>
                </li>
                <li><strong>Shared Controls (All Players):</strong>
                    <ul>
                        <li>Spacebar: Pause / Resume game for all players.</li>
                        <li>Double-Tap (Mobile): Pause / Resume game for all players. If game is over or not started, it will Start/Restart.</li>
                        <li>Main Control Button (below game): Context-sensitive Pause/Resume/Restart.</li>
                    </ul>
                </li>
            </ul>

            <h3>Two-Player Mode Details:</h3>
            <ul>
                <li><strong>Objective:</strong> Each player independently aims to complete ${maxRoundsPerGame} rounds by reaching their target length within the ${maxFoodPerRound} food item limit per round.</li>
                <li><strong>Food:</strong> Food items are shared. The first snake to reach a food item consumes it, and its effects apply only to that snake. All food on screen refreshes after any food is eaten.</li>
                <li><strong>Collisions:</strong>
                    <ul>
                        <li>Hitting a wall or your <em>own</em> snake's body will result in a game over for that player.</li>
                        <li><strong>Snake vs. Snake:</strong>
                            <ul>
                                <li>If Player 1's head hits Player 2's body, Player 1 is out.</li>
                                <li>If Player 2's head hits Player 1's body, Player 2 is out.</li>
                                <li>If Player 1's head hits Player 2's head (head-on collision), both players are out.</li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li><strong>Game End:</strong>
                    <ul>
                        <li>A player is 'out' if they hit something, fail to meet their target length before running out of food for the round, or are eliminated by the other player.</li>
                        <li>The game session ends when both players are out. The game will then declare a winner based on rounds completed or other criteria if applicable.</li>
                        <li>If one player completes all their rounds and the other is still playing, the game continues for the active player until they also complete their rounds or are out.</li>
                    </ul>
                </li>
                <li><strong>Winning:</strong> Try to complete all your rounds! If both players are active, the one who completes their rounds first or lasts longer with more rounds/length is generally considered the winner.</li>
            </ul>

            <h3>Player Status Displays:</h3>
            <p>Each player has their own status display showing their "Current Length", "Target Length" for the round, "Food This Round" (eaten/max), and "Rounds Cleared". A "GAME OVER" message will appear if a player is out.</p>

            <h3>Difficulty Levels:</h3>
            <p>Choose from Easy, Medium, or Hard before starting or during gameplay. Higher difficulty means a faster snake!</p>

            <h3>Food Types & Effects:</h3>
            <ul>
                <li><strong>Regular Food:</strong> Snake grows by one segment.</li>
                <li><strong>Apple (Yellow):</strong> Snake temporarily changes color. (Traditional score: +5).</li>
                <li><strong>Banana (Orange):</strong> Temporary speed boost. (Traditional score: +2).</li>
                <li><strong>Obstacle (Gray):</strong> Game Over for the player who eats it!</li>
                <li><strong>Red Block (Dark Red):</strong> Doubles current length. Eat 2 consecutively for width increase (max width still applies). (Traditional score: +2).</li>
                <li><strong>Green Block (Dark Green):</strong> Halves current length (if > 2 segments). (Traditional score: +2).</li>
            </ul>

            <p>Have fun playing together!</p>
        `; // Removed "External Button" section as it's not implemented yet.

        // Rules Toggle Button Listener
        toggleRulesBtn.addEventListener('click', () => {
            if (rulesContainer.style.display === 'none' || rulesContainer.style.display === '') {
                rulesContainer.style.display = 'block';
                toggleRulesBtn.textContent = 'Hide Rules';
            } else {
                rulesContainer.style.display = 'none';
                toggleRulesBtn.textContent = 'Show Rules';
            }
        });

        // Update button text based on initial rules visibility
        if (rulesContainer.style.display === 'block') {
            toggleRulesBtn.textContent = 'Hide Rules';
        } else {
            toggleRulesBtn.textContent = 'Show Rules';
        }
    });

    // Event Listener for the new controlBtn (replaces old startGameBtn listener)
    controlBtn.addEventListener('click', function() {
        if (!gameStarted) {
            initGame(); // from game.js
            difficultyButtons.forEach(btn => btn.style.display = 'inline-block'); // Show difficulty buttons
        } else if (gameOver) {
            initGame(); // from game.js
            difficultyButtons.forEach(btn => btn.style.display = 'inline-block'); // Show difficulty buttons
        } else {
            togglePauseGame(); // from game.js
        }
        // updateControlBtnText() is called by initGame/togglePauseGame in game.js
    });

    // Event Listener for Keyboard Controls
    document.addEventListener("keydown", e => {
      if (e.key === " ") {
        togglePauseGame();
        e.preventDefault();
      } else if (gameStarted && !isPaused) {
        // Player 1 Controls (Arrow Keys)
        if (e.key === "ArrowUp") { changeDirectionP1('up'); }
        else if (e.key === "ArrowDown") { changeDirectionP1('down'); }
        else if (e.key === "ArrowLeft") { changeDirectionP1('left'); }
        else if (e.key === "ArrowRight") { changeDirectionP1('right'); }

        // Player 2 Controls (WASD)
        else if (e.key.toLowerCase() === 'w' && !p2_gameOver) { changeDirectionP2('up'); }
        else if (e.key.toLowerCase() === 's' && !p2_gameOver) { changeDirectionP2('down'); }
        else if (e.key.toLowerCase() === 'a' && !p2_gameOver) { changeDirectionP2('left'); }
        else if (e.key.toLowerCase() === 'd' && !p2_gameOver) { changeDirectionP2('right'); }
      }
    });

    // Event Listener for Touchscreen Direction Buttons (Player 1 only for now)
    // This function is called by onclick attributes in HTML
    function setDirection(direction) { // This controls P1 by default
      if (gameStarted && !isPaused && !p1_gameOver) {
        changeDirectionP1(direction);
      }
    }

    // Event Listeners for Difficulty Buttons
    difficultyButtons.forEach(button => {
      button.addEventListener("click", () => {
        setGameDifficulty(button.dataset.level); // from game.js
      });
    });

    // Music Play/Pause Button
    playPauseBtn.addEventListener("click", () => {
      if (bgMusic.paused) {
        bgMusic.play();
        playPauseBtn.textContent = "Pause Music";
      } else {
        bgMusic.pause();
        playPauseBtn.textContent = "Play Music";
      }
    });

    // Current Time Display
    function updateTime() {
      const now = new Date();
      const hours = String(now.getHours()).padStart(2, '0');
      const minutes = String(now.getMinutes()).padStart(2, '0');
      const seconds = String(now.getSeconds()).padStart(2, '0');
      currentTimeDisplay.innerHTML = `${hours}:${minutes}:${seconds}`;
    }
    updateTime(); // Initial call
    setInterval(updateTime, 1000); // Update every second

    // Swipe Controls for Mobile
    let touchStartX = 0;
    let touchStartY = 0;
    let touchEndX = 0;
    let touchEndY = 0;
    const minSwipeDistance = 30; // Minimum distance for a swipe to be registered
    let lastTapTime = 0;
    const doubleTapDelay = 300; // Milliseconds
    const tapThreshold = 10; // Max pixels to move for it to be considered a tap

    canvas.addEventListener('touchstart', function(e) {
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
        // Using preventDefault here might interfere with double tap,
        // as it can prevent subsequent touchend in some cases if not handled carefully.
        // Let's manage preventDefault in touchend conditionally.
    }, false);

    canvas.addEventListener('touchmove', function(e) {
        // If there's enough movement, prevent default to avoid scrolling during a swipe.
        if (gameStarted && !isPaused) { // Only consider preventing scroll if game is active
            const currentX = e.touches[0].clientX;
            const currentY = e.touches[0].clientY;
            const diffX = currentX - touchStartX;
            const diffY = currentY - touchStartY;
            // If swipe is predominantly horizontal or vertical and exceeds a small threshold
            if (Math.abs(diffX) > tapThreshold || Math.abs(diffY) > tapThreshold) {
                // e.preventDefault(); // This can be too aggressive, let's test without first.
            }
        }
    }, false);

    canvas.addEventListener('touchend', function(e) {
        touchEndX = e.changedTouches[0].clientX;
        touchEndY = e.changedTouches[0].clientY;

        const diffX = touchEndX - touchStartX;
        const diffY = touchEndY - touchStartY;
        const currentTime = new Date().getTime();
        const tapTimeDifference = currentTime - lastTapTime;

        // Check if it's a tap (minimal movement)
        if (Math.abs(diffX) < tapThreshold && Math.abs(diffY) < tapThreshold) {
            e.preventDefault(); // Prevent default actions for taps (like zoom)
            if (tapTimeDifference < doubleTapDelay && tapTimeDifference > 0) {
                // Double tap
                if (gameStarted && !gameOver) {
                    togglePauseGame(); // Pause/resume active game
                } else {
                    // If game not started, or is over, double tap acts like "Start Game"
                    // Need to ensure UI elements like start button are handled correctly by initGame
                    const startGameButton = document.getElementById('startGameBtn');
                    if(startGameButton) startGameButton.style.display = 'none'; // Hide if visible
                    difficultyButtons.forEach(btn => btn.style.display = 'inline-block'); // Show
                    initGame();
                }
                lastTapTime = 0; // Reset lastTapTime to prevent triple tap from acting as double
            } else {
                // Single tap
                lastTapTime = currentTime;
            }
        } else { // Else, it's a swipe
            if (!gameStarted || isPaused) return; // Only process swipes if game is active and not paused

            if (Math.abs(diffX) > Math.abs(diffY)) { // Horizontal swipe
                if (diffX > minSwipeDistance) {
                    changeDirection('right');
                } else if (diffX < -minSwipeDistance) {
                    changeDirection('left');
                }
            } else if (Math.abs(diffY) > Math.abs(diffX)) { // Vertical swipe
                if (diffY > minSwipeDistance) {
                    changeDirection('down');
                } else if (diffY < -minSwipeDistance) {
                    changeDirection('up');
                }
            }
            // Consider adding e.preventDefault() here for swipes if page scrolling is an issue.
        }
    }, false);

    // Canvas click/tap to start game
    canvas.addEventListener('click', function() {
        if (!gameStarted) { // gameStarted is global from game.js
            initGame(); // from game.js
            difficultyButtons.forEach(btn => btn.style.display = 'inline-block'); // Show difficulty buttons
            // initGame will call updateControlBtnText via game.js
        }
    });

    // Ensure difficulty buttons are hidden initially, shown by initGame
    // This should be done once, perhaps after defining difficultyButtons or in DOMContentLoaded
    // For safety, let's ensure they are hidden on script load if not already by HTML.
    // However, the HTML already sets them to display:none. This line is redundant but harmless.
    // difficultyButtons.forEach(btn => btn.style.display = 'none');


  </script>
</body>
</html>
