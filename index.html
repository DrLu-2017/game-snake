<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Snake Battle</title>
  <style>
    body { margin: 0; display: flex; flex-direction: column; align-items: center; background: #111; color: #fff; font-family: sans-serif; }
    canvas { background: #333; /* margin-top: 20px; */ display: block; /* Ensure canvas is block for wrapper centering */ }
    .buttons { margin-top: 10px; display: flex; flex-wrap: wrap; justify-content: center; }
    .btn { padding: 10px 20px; margin: 5px; background: #333; color: #fff; border: none; font-size: 18px; border-radius: 8px; }
    .game-buttons .btn { padding: 5px 10px; font-size: 14px; } /* New rule for smaller game control buttons */
    #currentTimeDisplay { margin-top: 10px; font-size: 16px; }
    #scoreDisplay { margin-top: 5px; font-size: 20px; color: #fff; } /* This ID might be unused, but keeping original styles */
    #rulesContainer { margin-top: 15px; padding: 10px; border: 1px solid #555; border-radius: 5px; max-width: 500px; text-align: left; background-color: #222; }
    #rulesContainer h2 { margin-top: 0; color: #fff; text-align: center;}
    #rulesContainer h3 { margin-top: 15px; margin-bottom: 5px; color: #eee; }
    #rulesContainer ul { margin-left: 20px; padding-left: 10px; }
    #rulesContainer li { margin-bottom: 8px; line-height: 1.4; }
    #rulesContainer strong { color: #fff; }
    #rulesContainer p { margin-bottom: 10px; line-height: 1.4;}

    #p1StatusContainer, #p2StatusContainer {
        width: 100%;
        display: flex;
        align-items: center; /* Vertical alignment */
        padding: 5px 0;
        box-sizing: border-box;
        overflow: hidden; /* Prevent content from breaking out if too long */
        white-space: nowrap; /* Prevent text itself from wrapping within child elements */
        flex-wrap: nowrap; /* Prevent flex items from wrapping */
        justify-content: flex-start; /* Align items to the start */
    }

    #p1StatusContainer > h4, #p2StatusContainer > h4,
    #p1StatusContainer > div, #p2StatusContainer > div {
        /* display: inline; removed as flex items behave like blocks in flow */
        margin-right: 10px; /* Space between items */
        padding: 0; /* Reset padding */
        white-space: nowrap; /* Ensure text within each item doesn't wrap */
        flex-shrink: 0; /* Prevent items from shrinking if space is tight */
        flex-grow: 0; /* Prevent items from growing */
    }

    /* Remove margin from the last item in the container */
    #p1StatusContainer > *:last-child,
    #p2StatusContainer > *:last-child {
        margin-right: 0;
    }

    /* Specific style for h4 if it needs to be distinct */
    #p1StatusContainer h4, #p2StatusContainer h4 {
        font-weight: bold; /* Keep it bold */
        font-size: 1em; /* Relative to parent's 12px */
        /* margin-right is already set above, ensure no conflict or double margin if h4 is also a direct child */
    }

    /* Styles for Mobile Controls - Added/Modified for size increase */
    #gameAreaWrapper {
        position: relative; /* Crucial for absolute positioning of children */
        width: 400px; /* Match canvas width */
        height: 400px; /* Match canvas height */
        margin: 10px auto; /* Center the wrapper and provide some margin */
        /* background-color: #555; */ /* Optional: for visualizing the wrapper boundaries during testing */
    }
    #mobileControlsContainer {
        display: block; /* Or 'none' initially, JS handles visibility */
        position: absolute;
        top: 0;
        left: 0;
        width: 100%; /* Takes full width of gameAreaWrapper */
        height: 100%; /* Takes full height of gameAreaWrapper */
        /* background-color: rgba(255,0,0,0.1); */ /* Optional: for visualizing during testing */
        pointer-events: none; /* Allows clicks to pass through to the canvas if needed, buttons will override */
    }
    .mbtn { /* Mobile button styling - size from previous step, ensure position is absolute */
      font-size: 24px; /* Kept from previous step */
      width: 45px;   /* Kept from previous step */
      height: 45px;  /* Kept from previous step */
      line-height: 45px; /* Kept from previous step */
      border-radius: 5px; /* Kept from previous step */
      background: #444;
      color: #fff;
      border: 1px solid #555;
      cursor: pointer;
      box-sizing: border-box;
      position: absolute; /* Key change for individual positioning */
      z-index: 100; /* Ensure they are above other elements like canvas */
      pointer-events: auto; /* Make buttons clickable */
    }
    .mbtn:hover {
      background: #555;
    }

    #mobileBtnUp {
        top: 0;
        left: 50%;
        transform: translate(-50%, -100%); /* Places bottom edge of button at top edge of wrapper */
        grid-column: auto;
        grid-row: auto;
    }

    #mobileBtnDown {
        bottom: 0;
        left: 50%;
        transform: translate(-50%, 100%); /* Places top edge of button at bottom edge of wrapper */
        grid-column: auto;
        grid-row: auto;
    }

    #mobileBtnLeft {
        left: 0;
        top: 50%;
        transform: translate(-100%, -50%); /* Places right edge of button at left edge of wrapper */
        grid-column: auto;
        grid-row: auto;
    }

    #mobileBtnRight {
        right: 0; /* Anchor to the right edge */
        left: auto; /* Important: override any previous 'left' if #mobileBtnLeft was copied */
        top: 50%;
        transform: translate(100%, -50%); /* Places left edge of button at right edge of wrapper */
        grid-column: auto;
        grid-row: auto;
    }
  </style>
</head>
<body>
  <h1 style="display:none;">Snake Battle</h1>

  <div id="playerModeSelection" style="margin-bottom: 20px; text-align: center;">
      <h2>Select Game Mode:</h2>
      <label style="margin-right: 15px;"><input type="radio" name="playerMode" value="1P" checked> One Player</label>
      <label><input type="radio" name="playerMode" value="2P"> Two Players</label>
  </div>

  <div id="currentTimeDisplay"></div>

  <!-- Player 1 Status (Moved before canvas) -->
  <div id="p1StatusContainer" style="margin-top: 10px; padding: 5px; border: 1px solid #444; color: #ccc; font-size: 12px; margin-right: 5px; display:none;">
      <h4>Player 1 (Green)</h4>
      <div id="p1CurrentLengthDisplay">Current Length: 0</div>
      <div id="p1TargetLengthDisplay" style="">Target Length: 0</div>
      <div id="p1RoundsDisplay" style="">Rounds Cleared: 0 / 5</div>
      <div id="p1FoodThisRoundDisplay">Food This Round: 0 / 10</div>
      <div id="p1GameOverDisplay" style="color: red; display: none; font-weight: bold;">GAME OVER</div>
  </div>

  <div id="gameAreaWrapper">
      <canvas id="game" width="400" height="400" style="display:none;"></canvas>
      <div id="mobileControlsContainer" style="display: none;"> <!-- style from previous steps -->
          <button id="mobileBtnUp" class="mbtn">↑</button>
          <button id="mobileBtnLeft" class="mbtn">←</button>
          <button id="mobileBtnRight" class="mbtn">→</button>
          <button id="mobileBtnDown" class="mbtn">↓</button>
      </div>
  </div>

  <!-- Player 2 Status (Ensured after canvas) -->
  <div id="p2StatusContainer" style="margin-top: 10px; padding: 5px; border: 1px solid #444; color: #ccc; font-size: 12px; margin-left: 5px; display:none;">
      <h4>Player 2 (Blue)</h4>
      <div id="p2CurrentLengthDisplay">Current Length: 0</div>
      <div id="p2TargetLengthDisplay" style="">Target Length: 0</div>
      <div id="p2RoundsDisplay" style="">Rounds Cleared: 0 / 5</div>
      <div id="p2FoodThisRoundDisplay">Food This Round: 0 / 10</div>
      <div id="p2GameOverDisplay" style="color: red; display: none; font-weight: bold;">GAME OVER</div>
  </div>

  <!-- ScoreDisplay is removed as it's incorporated into P1 status. gameStatusContainer is replaced by P1 & P2 containers. -->
  <!-- <div id="scoreDisplay">Current Length: 0</div> -->
  <!-- <div id="gameStatusContainer" style="margin-top: 10px; padding: 5px; border: 1px solid #444; color: #ccc; font-size: 14px;">
      <div id="targetLengthDisplay" style="margin-bottom: 3px;">Target Length: 0</div>
      <div id="roundsDisplay" style="margin-bottom: 3px;">Rounds Cleared: 0 / 5</div>
      <div id="foodThisRoundDisplay">Food This Round: 0 / 10</div>
  </div> -->

  <div class="buttons game-buttons" style="display:flex;"> <!-- Added game-buttons class -->
    <button id="toggleRulesBtn" class="btn" style="display:none;">Show Rules</button> <!-- Added Rules Button, hidden -->
    <button class="btn" onclick="setDirection('up')" style="display:none;">↑</button> <!-- Hidden -->
    <button class="btn" onclick="setDirection('left')" style="display:none;">←</button> <!-- Hidden -->
    <button class="btn" onclick="setDirection('down')" style="display:none;">↓</button> <!-- Hidden -->
    <button class="btn" onclick="setDirection('right')" style="display:none;">→</button> <!-- Hidden -->
    <button id="controlBtn" class="btn">Start Game</button> <!-- ID changed, text updated by JS - REMAINS VISIBLE -->
    <button class="btn difficulty-btn" data-level="easy" style="display: none;">Easy</button> <!-- Already hidden, remains hidden -->
    <button class="btn difficulty-btn" data-level="medium" style="display: none;">Medium</button> <!-- Already hidden, remains hidden -->
    <button class="btn difficulty-btn" data-level="hard" style="display: none;">Hard</button> <!-- Already hidden, remains hidden -->
  </div>

  <div id="mobileControlsContainer" style="display: none;"> <!-- Initially hidden -->
    <button id="mobileBtnUp" class="mbtn">↑</button>
    <button id="mobileBtnLeft" class="mbtn">←</button>
    <button id="mobileBtnRight" class="mbtn">→</button>
    <button id="mobileBtnDown" class="mbtn">↓</button>
  </div>

  <!-- Rules Container -->
  <div id="rulesContainer" style="display: none; margin-top: 15px; padding: 10px; border: 1px solid #555; border-radius: 5px; max-width: 500px; text-align: left; background-color: #222;">
      <!-- Content will be populated by JavaScript -->
  </div>

  <!-- NOTE: "background_music.mp3" is a placeholder. Replace with a valid audio file path for music to play. -->
  <audio id="bgMusic" src="background_music.mp3" loop></audio>

  <div id="consecutiveFoodWarning" style="display: none; position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%); background-color: #333; color: #fff; padding: 20px; border: 1px solid red; box-shadow: 0 0 10px rgba(0,0,0,0.5); border-radius: 10px; z-index: 1000; text-align: center; width: 300px;">
      <p id="warningTextMessage" style="margin-bottom: 15px; font-size: 16px;"></p>
      <button id="warningAckBtn" style="padding: 10px 20px; background: #d9534f; color: #fff; border: none; border-radius: 5px; cursor: pointer; font-size: 16px;">OK</button>
  </div>

  <!-- Define global canvas/grid vars BEFORE loading external scripts that might use them -->
  <script>
    // Essential global variables for canvas and game setup
    // These must be defined before food.js, snake.js, game.js are loaded if they use these at parse time.
    // The canvas element must exist in the DOM before this script runs.
    // This script block should be placed after the canvas element, or within DOMContentLoaded.
    // For simplicity, assuming this entire script block (including this part) is at the end of <body>.
    const canvas = document.getElementById("game");
    let ctx, box, rows, cols; // Declare here, assign after checks

    if (!canvas) {
        console.error("[CRITICAL_ERROR] index.html: Canvas element with ID 'game' not found!");
        // Potentially halt further script execution or display a user-friendly error
    } else {
        ctx = canvas.getContext("2d");
        box = 15; // New cell size

        console.log("[DEBUG_STARTUP] index.html: canvas.width =", canvas.width, "canvas.height =", canvas.height);

        if (typeof canvas.width !== 'number' || canvas.width <= 0 ||
            typeof canvas.height !== 'number' || canvas.height <= 0 ||
            isNaN(canvas.width) || isNaN(canvas.height)) {
            console.error("[ERROR] index.html: Invalid canvas dimensions. Width or height is not a positive number.");
            // Default values for robustness, though HTML should prevent this.
            rows = 40;
            cols = 40;
            console.warn("[WARNING] index.html: Using default rows/cols (40x40) due to invalid canvas dimensions.");
        } else {
            rows = canvas.height / box; // Number of rows (Y dimension)
            cols = canvas.width / box;  // Number of columns (X dimension)
        }
        console.log("[DEBUG_STARTUP] index.html: Initial globals defined. Box: " + box + ", Rows: " + rows + ", Cols: " + cols);
    }
  </script>

  <!-- External game logic scripts -->
  <script src="food.js"></script>
  <script src="snake.js"></script>
  <script src="game.js"></script>

  <!-- Main inline script for UI, event listeners, and starting the game -->
  <script>
    document.addEventListener('DOMContentLoaded', function() {
        // This will run after the document is fully loaded.
        // The debug H1 text update has been removed.
        // try {
        //     const mainHeading = document.querySelector('h1');
        //     if (mainHeading) {
        //         // mainHeading.textContent = 'JS IS RUNNING!'; // This line is removed
        //     } else {
        //         // console.error('H1 element not found for JS test.'); // Also removing related console message
        //     }
        // } catch (e) {
        //     // console.error('Error in basic JS execution test: ', e); // Also removing related console message
        // }
    });

    // UI Elements & Event Listeners specific to index.html
    // Note: canvas, ctx, box, rows, cols are already defined in the script block above.

    function isMobileDevice() {
      return navigator.maxTouchPoints > 0;
    }

    const bgMusic = document.getElementById("bgMusic");
    const difficultyButtons = document.querySelectorAll(".difficulty-btn");
    const controlBtn = document.getElementById("controlBtn"); // Updated ID
    // const scoreDisplay = document.getElementById("scoreDisplay"); // Replaced by p1CurrentLengthDisplay etc.
    const toggleRulesBtn = document.getElementById('toggleRulesBtn');
    const rulesContainer = document.getElementById('rulesContainer');

    let selectedGameMode = '1P'; // Default to '1P' as it's checked in HTML
    let gameModeAtStart = '1P'; // Stores the game mode when the game actually starts

    function updateControlBtnText() {
        // Assumes controlBtn, gameStarted, gameOver, isPaused are accessible (gameOver is master)
        if (!gameStarted) {
            controlBtn.textContent = 'Start Game';
        } else if (gameOver) { // Master game over
            controlBtn.textContent = 'Restart Game';
        } else if (isPaused) {
            controlBtn.textContent = 'Resume Game';
        } else {
            controlBtn.textContent = 'Pause Game';
        }
    }

    // Initialize food and draw initial game screen (start message)
    // food.js and game.js functions are now globally available.
    document.addEventListener('DOMContentLoaded', () => {
      if (isMobileDevice()) {
        const twoPlayerRadio = document.querySelector('input[name="playerMode"][value="2P"]');
        if (twoPlayerRadio && twoPlayerRadio.parentElement) {
          twoPlayerRadio.parentElement.style.display = 'none'; // Hide the label containing the radio
        }
        const onePlayerRadio = document.querySelector('input[name="playerMode"][value="1P"]');
        if (onePlayerRadio) {
          onePlayerRadio.checked = true;
        }
        selectedGameMode = '1P'; // Ensure selectedGameMode is also updated
      }

      const warningContainer = document.getElementById('consecutiveFoodWarning');
      const warningAckBtn = document.getElementById('warningAckBtn');
      // const warningTextMessage = document.getElementById('warningTextMessage'); // Not strictly needed here if game.js handles text

      if (warningAckBtn && warningContainer) {
          warningAckBtn.addEventListener('click', () => {
              if (typeof acknowledgeFoodWarning === 'function') {
                  acknowledgeFoodWarning(); // This function will be defined in game.js
              } else {
                  // Fallback if function isn't found
                  console.warn("acknowledgeFoodWarning function not found. Hiding warning via index.html.");
                  warningContainer.style.display = 'none';
              }
          });
      } else {
          console.error("Warning container or ACK button not found in index.html.");
      }

      const desktopButtonsDiv = document.querySelector('.buttons');
      const mobileControlsContainer = document.getElementById('mobileControlsContainer');

      if (isMobileDevice()) {
        // Hide original direction buttons
        const allDesktopButtons = desktopButtonsDiv.querySelectorAll('button.btn');
        allDesktopButtons.forEach(btn => {
          const onclickAttr = btn.getAttribute('onclick');
          if (onclickAttr && onclickAttr.startsWith("setDirection(")) {
            btn.style.display = 'none';
          }
        });
        // Mobile controls container visibility will be handled by the game start logic primarily
        // but ensure it's ready to be shown (display:grid) vs display:none from HTML
        // mobileControlsContainer.style.display = 'grid'; // This will be handled by controlBtn logic

        // Add event listeners for mobile buttons
        document.getElementById('mobileBtnUp').onclick = () => setDirection('up');
        document.getElementById('mobileBtnLeft').onclick = () => setDirection('left');
        document.getElementById('mobileBtnRight').onclick = () => setDirection('right');
        document.getElementById('mobileBtnDown').onclick = () => setDirection('down');
      } else {
        mobileControlsContainer.style.display = 'none'; // Ensure mobile controls are hidden on desktop
      }

      try {
        console.log("[DEBUG_STARTUP] index.html: DOMContentLoaded: Initial drawGame call preparing to show start screen.");
        drawGame(); // Call from game.js to draw the initial "Press Start Game" screen.
        updateControlBtnText(); // Set initial text for controlBtn
        updateGameStatusDisplay(); // Initialize P1/P2 status displays

        // First visit logic for rules display
        try {
            if (localStorage.getItem('hasVisitedBefore') === null) {
                // First visit
                if (rulesContainer) {
                    rulesContainer.style.display = 'block';
                    if (toggleRulesBtn) { // Ensure toggleRulesBtn exists
                         toggleRulesBtn.textContent = 'Hide Rules';
                    }
                }
                localStorage.setItem('hasVisitedBefore', 'true');
            } else {
                // Subsequent visits - rules default to hidden unless shown by other logic
                // The check rulesContainer.style.display !== 'block' ensures we don't override if rules were shown by other means
                // (e.g. if game starts and shows rules by default - though current logic doesn't do that)
                if (rulesContainer && rulesContainer.style.display !== 'block') { 
                     rulesContainer.style.display = 'none'; // Default for subsequent visits
                     if (toggleRulesBtn) {
                          toggleRulesBtn.textContent = 'Show Rules';
                     }
                } else if (rulesContainer && rulesContainer.style.display === 'block'){
                    // If it's a subsequent visit AND rules are somehow already block (e.g. user interaction before this script runs fully, unlikely)
                    // ensure button text is correct.
                    if (toggleRulesBtn) {
                        toggleRulesBtn.textContent = 'Hide Rules';
                    }
                }
            }
        } catch (e) {
            console.error("Error accessing localStorage or setting rules display: ", e);
            // Fallback: rules remain hidden by default if localStorage fails
            if (rulesContainer) rulesContainer.style.display = 'none';
            if (toggleRulesBtn) toggleRulesBtn.textContent = 'Show Rules';
        }

        // Populate Rules
        if (rulesContainer && typeof maxRoundsPerGame !== 'undefined' && typeof maxFoodPerRound !== 'undefined') {
            rulesContainer.innerHTML = `
            <h2>Welcome to Snake!</h2>

            <h3>Game Mode: Two-Player Target Length</h3>
            <p>Compete with a friend or play cooperatively! Each player controls their own snake and tries to complete <strong>${maxRoundsPerGame} rounds</strong>. In each round, players must grow their snake to a randomly assigned target length by eating food. Each player has a limit of <strong>${maxFoodPerRound}</strong> food items per round to reach their target. Your snake's current length is your primary score for the round.</p>

            <h3>Controls:</h3>
            <ul>
                <li><strong>Player 1 (Green Snake):</strong>
                    <ul>
                        <li>Arrow Keys (Up, Down, Left, Right): Control snake direction.</li>
                    </ul>
                </li>
                <li><strong>Player 2 (Blue Snake):</strong>
                    <ul>
                        <li>W, A, S, D Keys: Control snake direction (W=Up, A=Left, S=Down, D=Right).</li>
                    </ul>
                </li>
                <li><strong>Shared Controls (All Players):</strong>
                    <ul>
                        <li>Spacebar: Pause / Resume game for all players.</li>
                        <li>Double-Tap (Mobile): Pause / Resume game for all players. If game is over or not started, it will Start/Restart.</li>
                        <li>Main Control Button (below game): Context-sensitive Pause/Resume/Restart.</li>
                    </ul>
                </li>
            </ul>

            <h3>Two-Player Mode Details:</h3>
            <ul>
                <li><strong>Objective:</strong> Each player independently aims to complete ${maxRoundsPerGame} rounds by reaching their target length within the ${maxFoodPerRound} food item limit per round.</li>
                <li><strong>Food:</strong> Food items are shared. The first snake to reach a food item consumes it, and its effects apply only to that snake. All food on screen refreshes after any food is eaten.</li>
                <li><strong>Collisions:</strong>
                    <ul>
                        <li>Hitting a wall or your <em>own</em> snake's body will result in a game over for that player.</li>
                        <li><strong>Snake vs. Snake:</strong>
                            <ul>
                                <li>If Player 1's head hits Player 2's body, Player 1 is out.</li>
                                <li>If Player 2's head hits Player 1's body, Player 2 is out.</li>
                                <li>If Player 1's head hits Player 2's head (head-on collision), both players are out.</li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li><strong>Game End:</strong>
                    <ul>
                        <li>A player is 'out' if they hit something, fail to meet their target length before running out of food for the round, or are eliminated by the other player.</li>
                        <li>The game session ends when both players are out. The game will then declare a winner based on rounds completed or other criteria if applicable.</li>
                        <li>If one player completes all their rounds and the other is still playing, the game continues for the active player until they also complete their rounds or are out.</li>
                    </ul>
                </li>
                <li><strong>Winning:</strong> Try to complete all your rounds! If both players are active, the one who completes their rounds first or lasts longer with more rounds/length is generally considered the winner.</li>
            </ul>

            <h3>Player Status Displays:</h3>
            <p>Each player has their own status display showing their "Current Length", "Target Length" for the round, "Food This Round" (eaten/max), and "Rounds Cleared". A "GAME OVER" message will appear if a player is out.</p>

            <h3>Difficulty Levels:</h3>
            <p>Choose from Easy, Medium, or Hard before starting or during gameplay. Higher difficulty means a faster snake!</p>

            <h3>Food Types & Effects:</h3>
            <ul>
                <li><strong>Mousse (mousse.png):</strong> Temporarily changes game difficulty to 'hard' and doubles your snake's width for 3 turns. Score: +3.</li>
                <li><strong>Apple (apple.png):</strong> Snake temporarily changes color and game speed is reduced (slower snake) for a short period. Score: +5.</li>
                <li><strong>Pasteque (pasteque.png):</strong> Grants a temporary speed boost for a short period. Score: +2.</li>
                <li><strong>Obstacle (wall.png):</strong> Game Over for the player who eats it! Score: +0.</li>
                <li><strong>Citron (citron.png):</strong> Doubles your snake's current length. Eat 2 Citrons consecutively to increase snake width. Score: +2.</li>
                <li><strong>Orange (orange.png):</strong> Halves your snake's current length (if length is > 2 segments). Score: +2.</li>
            </ul>

            <p>Have fun playing together!</p>
        `; // Removed "External Button" section as it's not implemented yet.
        } else {
            console.error("Error populating rules: rulesContainer or global game parameters (maxRoundsPerGame, maxFoodPerRound) not found.");
        }

        // Rules Toggle Button Listener
        if (toggleRulesBtn && rulesContainer) {
            toggleRulesBtn.addEventListener('click', () => {
                try { // Inner try-catch for the callback logic
                    if (rulesContainer.style.display === 'none' || rulesContainer.style.display === '') {
                        rulesContainer.style.display = 'block';
                        toggleRulesBtn.textContent = 'Hide Rules';
                    } else {
                        rulesContainer.style.display = 'none';
                        toggleRulesBtn.textContent = 'Show Rules';
                    }
                } catch (e) {
                    console.error("Error in toggleRulesBtn click callback:", e);
                }
            });

            // Update button text based on initial rules visibility
            try { // Inner try-catch for this specific logic
                if (rulesContainer.style.display === 'block') {
                    toggleRulesBtn.textContent = 'Hide Rules';
                } else {
                    toggleRulesBtn.textContent = 'Show Rules';
                }
            } catch (e) {
                console.error("Error setting initial toggleRulesBtn text:", e);
            }
        } else {
            console.error("toggleRulesBtn or rulesContainer not found for event listener attachment or initial text setting.");
        }

        // Event listeners for player mode radio buttons
        const playerModeRadios = document.querySelectorAll('input[name="playerMode"]');
        playerModeRadios.forEach(radio => {
            radio.addEventListener('change', (event) => {
                const newMode = event.target.value;
                const playerModeSelectionUI = document.getElementById('playerModeSelection');

                if (gameStarted && !gameOver && gameModeAtStart === '1P' && newMode === '2P') {
                    if (confirm("A second player wants to join. Restart the game in 2-player mode?")) {
                        selectedGameMode = '2P';
                        gameModeAtStart = '2P'; // Update for future checks
                        initGame(); // This will handle restarting the game in 2P mode
                        if (playerModeSelectionUI) playerModeSelectionUI.style.display = 'none';
                    } else {
                        // Revert the radio button selection
                        document.querySelector('input[name="playerMode"][value="1P"]').checked = true;
                        selectedGameMode = '1P'; // Ensure selectedGameMode is consistent
                    }
                } else if (gameStarted && !gameOver && gameModeAtStart === '2P' && newMode === '1P') {
                    alert("Cannot switch to 1-Player mode while a 2-Player game is in progress. Please restart the game to change modes.");
                    document.querySelector('input[name="playerMode"][value="2P"]').checked = true;
                    selectedGameMode = '2P'; // Ensure selectedGameMode is consistent
                } else { // Game not started, or game is over - allow changing mode for next game
                    selectedGameMode = newMode;
                    // gameModeAtStart will be updated when the game actually starts next time
                }
            });
        });

      } catch (e) {
        console.error("Error in main DOMContentLoaded setup:", e);
      }
    });

    // Event Listener for the new controlBtn (replaces old startGameBtn listener)
    try {
        if (controlBtn) {
            controlBtn.addEventListener('click', function() {
                try { // Inner try-catch for the callback logic
                    if (!gameStarted) {
                        // Get selected player mode
                        const selectedModeInput = document.querySelector('input[name="playerMode"]:checked');
                        if (selectedModeInput) {
                            selectedGameMode = selectedModeInput.value;
                        }
                        gameModeAtStart = selectedGameMode; // Set gameModeAtStart here
                        console.log("Selected game mode at start:", gameModeAtStart);

                        // Hide player mode selection UI
                        const playerModeSelectionUI = document.getElementById('playerModeSelection');
                        if (playerModeSelectionUI) {
                            playerModeSelectionUI.style.display = 'none';
                        }

                        // Show main game UI elements
                        const p1Status = document.getElementById('p1StatusContainer');
                        if (p1Status) p1Status.style.display = 'block';

                        // P2 container visibility will be handled by initGame based on selectedGameMode,
                        // but we can make it 'block' here initially, and initGame can hide it if 1P.
                        const p2Status = document.getElementById('p2StatusContainer');
                        if (p2Status) p2Status.style.display = 'block'; // Visibility also managed by updateGameStatusDisplay

                        const gameCanvas = document.getElementById('game');
                        if (gameCanvas) gameCanvas.style.display = 'block';

                        const buttonsDiv = document.querySelector('.buttons');
                        if (buttonsDiv) {
                            buttonsDiv.style.display = 'flex'; // Make the main buttons container visible

                            // Show specific buttons that were hidden individually
                            const toggleRulesBtnElem = document.getElementById('toggleRulesBtn');
                            if (toggleRulesBtnElem) toggleRulesBtnElem.style.display = 'inline-block';

                            // Show direction buttons (select by onclick attribute content - fragile but necessary without better selectors)
                            const allButtonsInContainer = buttonsDiv.querySelectorAll('button.btn');
                            allButtonsInContainer.forEach(btn => {
                                const onclickAttr = btn.getAttribute('onclick');
                                if (onclickAttr && onclickAttr.startsWith("setDirection(")) {
                                    // These original on-screen direction buttons should always be hidden (PC uses keyboard, mobile uses new controls)
                                    btn.style.display = 'none';
                                }
                            });

                            // Show mobile controls ONLY on mobile devices
                            if (isMobileDevice()) {
                                const mobileControls = document.getElementById('mobileControlsContainer');
                                if (mobileControls) mobileControls.style.display = 'block'; // Changed from 'grid' to 'block'
                            }
                            // No need for an else here to hide mobileControls,
                            // as DOMContentLoaded already hides it for non-mobile,
                            // and game restart logic also hides it.
                        }

                        const rulesDiv = document.getElementById('rulesContainer');
                        // Rules container visibility is handled by its own toggle button,
                        // but we ensure it's 'block' initially when game starts,
                        // then user can toggle. Or 'none' if toggleRulesBtn should be the only way to show it.
                        // For now, let's make it block, consistent with other elements.
                        if (rulesDiv) rulesDiv.style.display = 'block';

                        document.body.style.overflow = 'hidden'; // Disable scrollbars
                        initGame(); // from game.js - this will also handle P2 UI based on selectedGameMode
                        if (difficultyButtons) difficultyButtons.forEach(btn => btn.style.display = 'inline-block'); // Show difficulty buttons
                    } else if (gameOver) {
                        document.body.style.overflow = 'auto'; // Enable scrollbars
                        // On restart, player mode selection should reappear.
                        const playerModeSelectionUI = document.getElementById('playerModeSelection');
                        if (playerModeSelectionUI) {
                            playerModeSelectionUI.style.display = 'block'; // Show mode selection
                        }
                        // Hide game elements again until mode is re-selected and game started
                        const p1Status = document.getElementById('p1StatusContainer');
                        if (p1Status) p1Status.style.display = 'none';
                        const p2Status = document.getElementById('p2StatusContainer');
                        if (p2Status) p2Status.style.display = 'none';
                        const gameCanvas = document.getElementById('game');
                        if (gameCanvas) gameCanvas.style.display = 'none';
                        const buttonsDiv = document.querySelector('.buttons');
                        // if (buttonsDiv) buttonsDiv.style.display = 'none'; // controlBtn itself is in this div, so don't hide the whole div.
                        const rulesDiv = document.getElementById('rulesContainer');
                        if (rulesDiv) rulesDiv.style.display = 'none';

                        // Hide mobile controls on game restart/end
                        const mobileControls = document.getElementById('mobileControlsContainer');
                        if (mobileControls) mobileControls.style.display = 'none';

                        // initGame(); // from game.js - NO, initGame is called when Start is pressed again after mode selection
                        // Instead, we need to reset gameStarted, gameOver flags and update button text
                        gameStarted = false;
                        gameOver = false; // Reset master game over
                        p1_gameOver = false; // Reset player-specific game over
                        p2_gameOver = false; // Reset player-specific game over
                        updateControlBtnText(); // Should now say "Start Game"
                        drawGame(); // Show the "Press Start Game" message
                        // Difficulty buttons should be hidden again.
                        if (difficultyButtons) difficultyButtons.forEach(btn => btn.style.display = 'none');

                    // The redundant "else if (gameOver)" block that was here has been removed.
                    } else { // This block is for pause/resume
                        togglePauseGame(); // from game.js, this flips the isPaused state
                        if (isPaused) {
                            document.body.style.overflow = 'auto'; // Game is PAUSED, so ENABLE scrollbars
                            console.log("Game paused, scrollbars enabled.");
                        } else {
                            document.body.style.overflow = 'hidden'; // Game is RESUMED, so DISABLE scrollbars
                            console.log("Game resumed, scrollbars disabled.");
                        }
                    }
                    // updateControlBtnText() is called by initGame/togglePauseGame in game.js
                } catch (e) {
                    console.error("Error in controlBtn click callback:", e);
                }
            });
        } else {
            console.error("controlBtn not found for event listener attachment.");
        }
    } catch (e) {
        console.error("Error attaching event listener for controlBtn:", e);
    }

    // Event Listener for Keyboard Controls
    try {
        document.addEventListener("keydown", e => {
            try { // Inner try-catch for the callback logic
                if (e.key === " ") {
                    e.preventDefault(); // Keep preventDefault at the start
                    if (gameStarted && !gameOver) { // Only toggle pause if game is running and not over
                        togglePauseGame();
                        if (isPaused) {
                            document.body.style.overflow = 'auto'; // Game is PAUSED, ENABLE scrollbars
                            console.log("Game paused via spacebar, scrollbars enabled.");
                        } else {
                            document.body.style.overflow = 'hidden'; // Game is RESUMED, DISABLE scrollbars
                            console.log("Game resumed via spacebar, scrollbars disabled.");
                        }
                    }
                } else if (gameStarted && !isPaused) {
                    // Player 1 Controls (Arrow Keys)
                    if (e.key === "ArrowUp") { changeDirectionP1('up'); }
                    else if (e.key === "ArrowDown") { changeDirectionP1('down'); }
                    else if (e.key === "ArrowLeft") { changeDirectionP1('left'); }
                    else if (e.key === "ArrowRight") { changeDirectionP1('right'); }

                    // Player 2 Controls (WASD) - Conditional on isPlayer2Active
                    else if (typeof isPlayer2Active !== 'undefined' && isPlayer2Active && e.key.toLowerCase() === 'w' && !p2_gameOver) { changeDirectionP2('up'); }
                    else if (typeof isPlayer2Active !== 'undefined' && isPlayer2Active && e.key.toLowerCase() === 's' && !p2_gameOver) { changeDirectionP2('down'); }
                    else if (typeof isPlayer2Active !== 'undefined' && isPlayer2Active && e.key.toLowerCase() === 'a' && !p2_gameOver) { changeDirectionP2('left'); }
                    else if (typeof isPlayer2Active !== 'undefined' && isPlayer2Active && e.key.toLowerCase() === 'd' && !p2_gameOver) { changeDirectionP2('right'); }
                }
            } catch (er) { // Changed 'e' to 'er' to avoid conflict with event 'e'
                console.error("Error in keydown event callback:", er);
            }
        });
    } catch (e) {
        console.error("Error attaching keydown event listener for document:", e);
    }

    // Event Listener for Touchscreen Direction Buttons (Player 1 only for now)
    // This function is called by onclick attributes in HTML
    function setDirection(direction) { // This controls P1 by default
      try {
        if (gameStarted && !isPaused && !p1_gameOver) {
          changeDirectionP1(direction);
        }
      } catch (e) {
        console.error("Error in setDirection function:", e);
      }
    }

    // Event Listeners for Difficulty Buttons
    try {
        if (difficultyButtons) {
            difficultyButtons.forEach(button => {
                if (button) {
                    button.addEventListener("click", () => {
                        try { // Inner try-catch for the callback logic
                            setGameDifficulty(button.dataset.level); // from game.js
                        } catch (e) {
                            console.error("Error in difficulty button click callback:", e);
                        }
                    });
                } else {
                    console.error("A difficulty button element was not found during forEach loop.");
                }
            });
        } else {
            console.error("difficultyButtons NodeList not found for event listener attachment.");
        }
    } catch (e) {
        console.error("Error attaching event listeners for difficultyButtons:", e);
    }

    // Music Play/Pause Button (Removed)

    // Current Time Display
    function updateTime() {
      // It's good practice to check if currentTimeDisplay exists within the function
      // especially if it's called by setInterval and the element might disappear.
      try {
        if (currentTimeDisplay) {
          const now = new Date();
          const hours = String(now.getHours()).padStart(2, '0');
          const minutes = String(now.getMinutes()).padStart(2, '0');
          const seconds = String(now.getSeconds()).padStart(2, '0');
          currentTimeDisplay.innerHTML = `${hours}:${minutes}:${seconds}`;
        }
      } catch (e) {
        console.error("Error in updateTime function body:", e);
        // Optionally, could clear interval here if error is persistent
      }
    }

    try {
        // updateTime is called immediately and then via setInterval
        if (typeof currentTimeDisplay !== 'undefined' && currentTimeDisplay) { // Check if currentTimeDisplay exists
             updateTime(); // Initial call
             setInterval(updateTime, 1000); // Update every second
        } else {
            console.error("currentTimeDisplay element not found for time updates.");
        }
    } catch (e) {
        console.error("Error in initial time update or setInterval setup:", e);
    }

    // Swipe Controls for Mobile
    let touchStartX = 0;
    let touchStartY = 0;
    let touchEndX = 0;
    let touchEndY = 0;
    const minSwipeDistance = 30; // Minimum distance for a swipe to be registered
    let lastTapTime = 0;
    const doubleTapDelay = 300; // Milliseconds
    const tapThreshold = 10; // Max pixels to move for it to be considered a tap

    try {
        // Check if canvas exists (it should, given earlier checks, but good practice for standalone blocks)
        if (canvas) {
            canvas.addEventListener('touchstart', function(e) {
                try {
                    touchStartX = e.touches[0].clientX;
                    touchStartY = e.touches[0].clientY;
                } catch (er) { console.error("Error in touchstart callback:", er); }
            }, false);

            canvas.addEventListener('touchmove', function(e) {
                // Minimal logic, direct error less likely here unless e.touches is problematic
                // For complex logic, a try-catch would be good.
            }, false);

            canvas.addEventListener('touchend', function(e) {
                try {
                    touchEndX = e.changedTouches[0].clientX;
                    touchEndY = e.changedTouches[0].clientY;

                    const diffX = touchEndX - touchStartX;
                    const diffY = touchEndY - touchStartY;
                    const currentTime = new Date().getTime();
                    const tapTimeDifference = currentTime - lastTapTime;

                    if (Math.abs(diffX) < tapThreshold && Math.abs(diffY) < tapThreshold) {
                        e.preventDefault();
                        if (tapTimeDifference < doubleTapDelay && tapTimeDifference > 0) { // Double tap
                            if (gameStarted && !gameOver) {
                                togglePauseGame();
                                if (isPaused) {
                                    document.body.style.overflow = 'auto'; // Game is PAUSED, ENABLE scrollbars
                                    console.log("Game paused via double-tap, scrollbars enabled.");
                                } else {
                                    document.body.style.overflow = 'hidden'; // Game is RESUMED, DISABLE scrollbars
                                    console.log("Game resumed via double-tap, scrollbars disabled.");
                                }
                            } else { // Game not started or is over, double tap starts/restarts
                                const startGameButton = document.getElementById('startGameBtn'); // This ID might be legacy
                                if(startGameButton) startGameButton.style.display = 'none';
                                if (difficultyButtons) difficultyButtons.forEach(btn => btn.style.display = 'inline-block');
                                initGame();
                            }
                            lastTapTime = 0;
                        } else {
                            lastTapTime = currentTime;
                        }
                    } else {
                        if (!gameStarted || isPaused) return;

                        if (Math.abs(diffX) > Math.abs(diffY)) {
                            if (diffX > minSwipeDistance) { changeDirection('right'); }
                            else if (diffX < -minSwipeDistance) { changeDirection('left'); }
                        } else if (Math.abs(diffY) > Math.abs(diffX)) {
                            if (diffY > minSwipeDistance) { changeDirection('down'); }
                            else if (diffY < -minSwipeDistance) { changeDirection('up'); }
                        }
                    }
                } catch (er) { console.error("Error in touchend callback:", er); }
            }, false);

            // Canvas click/tap to start game (also on canvas)
            canvas.addEventListener('click', function() {
                try {
                    if (!gameStarted) {
                        initGame();
                        if (difficultyButtons) difficultyButtons.forEach(btn => btn.style.display = 'inline-block');
                    }
                } catch (er) { console.error("Error in canvas click callback:", er); }
            });
        } else {
            console.error("Canvas element not found for touch/click event listener attachment.");
        }
    } catch (e) {
        console.error("Error attaching touch/click event listeners for canvas:", e);
    }

    // Ensure difficulty buttons are hidden initially, shown by initGame
    // This should be done once, perhaps after defining difficultyButtons or in DOMContentLoaded
    // For safety, let's ensure they are hidden on script load if not already by HTML.
    // However, the HTML already sets them to display:none. This line is redundant but harmless.
    // difficultyButtons.forEach(btn => btn.style.display = 'none');


  </script>
</body>
</html>
