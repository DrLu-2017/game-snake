<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>贪吃蛇游戏</title>
  <style>
    body { margin: 0; display: flex; flex-direction: column; align-items: center; background: #111; color: #fff; font-family: sans-serif; }
    canvas { background: #333; margin-top: 20px; }
    .buttons { margin-top: 10px; display: flex; flex-wrap: wrap; justify-content: center; }
    .btn { padding: 10px 20px; margin: 5px; background: #333; color: #fff; border: none; font-size: 18px; border-radius: 8px; }
    #currentTimeDisplay { margin-top: 10px; font-size: 16px; }
    #scoreDisplay { margin-top: 5px; font-size: 20px; color: #fff; }
    #rulesContainer { margin-top: 15px; padding: 10px; border: 1px solid #555; border-radius: 5px; max-width: 500px; text-align: left; background-color: #222; }
    #rulesContainer h2 { margin-top: 0; color: #fff; text-align: center;}
    #rulesContainer h3 { margin-top: 15px; margin-bottom: 5px; color: #eee; }
    #rulesContainer ul { margin-left: 20px; padding-left: 10px; }
    #rulesContainer li { margin-bottom: 8px; line-height: 1.4; }
    #rulesContainer strong { color: #fff; }
    #rulesContainer p { margin-bottom: 10px; line-height: 1.4;}
  </style>
</head>
<body>
  <h1>贪吃蛇游戏</h1>

  <div id="playerModeSelection" style="margin-bottom: 20px; text-align: center;">
      <h2>Select Game Mode:</h2>
      <label style="margin-right: 15px;"><input type="radio" name="playerMode" value="1P" checked> One Player</label>
      <label><input type="radio" name="playerMode" value="2P"> Two Players</label>
  </div>

  <div id="currentTimeDisplay"></div>

  <!-- Player 1 Status -->
  <div id="p1StatusContainer" style="margin-top: 10px; padding: 5px; border: 1px solid #444; color: #ccc; font-size: 14px; width: 200px; text-align: center; margin-right: 5px; display:none;">
      <h4>Player 1 (Green)</h4>
      <div id="p1CurrentLengthDisplay">Current Length: 0</div>
      <div id="p1TargetLengthDisplay" style="margin-bottom: 3px;">Target Length: 0</div>
      <div id="p1RoundsDisplay" style="margin-bottom: 3px;">Rounds Cleared: 0 / 5</div>
      <div id="p1FoodThisRoundDisplay">Food This Round: 0 / 10</div>
      <div id="p1GameOverDisplay" style="color: red; display: none; font-weight: bold;">GAME OVER</div>
  </div>

  <!-- Player 2 Status -->
  <div id="p2StatusContainer" style="margin-top: 10px; padding: 5px; border: 1px solid #444; color: #ccc; font-size: 14px; width: 200px; text-align: center; margin-left: 5px; display:none;">
      <h4>Player 2 (Blue)</h4>
      <div id="p2CurrentLengthDisplay">Current Length: 0</div>
      <div id="p2TargetLengthDisplay" style="margin-bottom: 3px;">Target Length: 0</div>
      <div id="p2RoundsDisplay" style="margin-bottom: 3px;">Rounds Cleared: 0 / 5</div>
      <div id="p2FoodThisRoundDisplay">Food This Round: 0 / 10</div>
      <div id="p2GameOverDisplay" style="color: red; display: none; font-weight: bold;">GAME OVER</div>
  </div>

  <!-- ScoreDisplay is removed as it's incorporated into P1 status. gameStatusContainer is replaced by P1 & P2 containers. -->
  <!-- <div id="scoreDisplay">Current Length: 0</div> -->
  <!-- <div id="gameStatusContainer" style="margin-top: 10px; padding: 5px; border: 1px solid #444; color: #ccc; font-size: 14px;">
      <div id="targetLengthDisplay" style="margin-bottom: 3px;">Target Length: 0</div>
      <div id="roundsDisplay" style="margin-bottom: 3px;">Rounds Cleared: 0 / 5</div>
      <div id="foodThisRoundDisplay">Food This Round: 0 / 10</div>
  </div> -->

  <canvas id="game" width="400" height="400" style="display:none;"></canvas>
  <div class="buttons" style="display:flex;"> <!-- Changed to display:flex -->
    <button id="toggleRulesBtn" class="btn" style="display:none;">Show Rules</button> <!-- Added Rules Button, hidden -->
    <button class="btn" onclick="setDirection('up')" style="display:none;">↑</button> <!-- Hidden -->
    <button class="btn" onclick="setDirection('left')" style="display:none;">←</button> <!-- Hidden -->
    <button class="btn" onclick="setDirection('down')" style="display:none;">↓</button> <!-- Hidden -->
    <button class="btn" onclick="setDirection('right')" style="display:none;">→</button> <!-- Hidden -->
    <button id="controlBtn" class="btn">Start Game</button> <!-- ID changed, text updated by JS - REMAINS VISIBLE -->
    <button id="playPauseBtn" class="btn" style="display:none;">Play/Pause Music</button><span style="font-size: 12px; color: #aaa; margin-left: 5px; display:none;">(Music: 'background_music.mp3' needed)</span> <!-- Button and span hidden -->
    <button class="btn difficulty-btn" data-level="easy" style="display: none;">Easy</button> <!-- Already hidden, remains hidden -->
    <button class="btn difficulty-btn" data-level="medium" style="display: none;">Medium</button> <!-- Already hidden, remains hidden -->
    <button class="btn difficulty-btn" data-level="hard" style="display: none;">Hard</button> <!-- Already hidden, remains hidden -->
  </div>

  <!-- Rules Container -->
  <div id="rulesContainer" style="display: none; margin-top: 15px; padding: 10px; border: 1px solid #555; border-radius: 5px; max-width: 500px; text-align: left; background-color: #222;">
      <!-- Content will be populated by JavaScript -->
  </div>

  <!-- NOTE: "background_music.mp3" is a placeholder. Replace with a valid audio file path for music to play. -->
  <audio id="bgMusic" src="background_music.mp3" loop></audio>

  <!-- Define global canvas/grid vars BEFORE loading external scripts that might use them -->
  <script>
    // Essential global variables for canvas and game setup
    // These must be defined before food.js, snake.js, game.js are loaded if they use these at parse time.
    // The canvas element must exist in the DOM before this script runs.
    // This script block should be placed after the canvas element, or within DOMContentLoaded.
    // For simplicity, assuming this entire script block (including this part) is at the end of <body>.
    const canvas = document.getElementById("game");
    let ctx, box, rows, cols; // Declare here, assign after checks

    if (!canvas) {
        console.error("[CRITICAL_ERROR] index.html: Canvas element with ID 'game' not found!");
        // Potentially halt further script execution or display a user-friendly error
    } else {
        ctx = canvas.getContext("2d");
        box = 10; // New cell size

        console.log("[DEBUG_STARTUP] index.html: canvas.width =", canvas.width, "canvas.height =", canvas.height);

        if (typeof canvas.width !== 'number' || canvas.width <= 0 ||
            typeof canvas.height !== 'number' || canvas.height <= 0 ||
            isNaN(canvas.width) || isNaN(canvas.height)) {
            console.error("[ERROR] index.html: Invalid canvas dimensions. Width or height is not a positive number.");
            // Default values for robustness, though HTML should prevent this.
            rows = 40;
            cols = 40;
            console.warn("[WARNING] index.html: Using default rows/cols (40x40) due to invalid canvas dimensions.");
        } else {
            rows = canvas.height / box; // Number of rows (Y dimension)
            cols = canvas.width / box;  // Number of columns (X dimension)
        }
        console.log("[DEBUG_STARTUP] index.html: Initial globals defined. Box: " + box + ", Rows: " + rows + ", Cols: " + cols);
    }
  </script>

  <!-- External game logic scripts -->
  <script src="food.js"></script>
  <script src="snake.js"></script>
  <script src="game.js"></script>

  <!-- Main inline script for UI, event listeners, and starting the game -->
  <script>
    document.addEventListener('DOMContentLoaded', function() {
        // This will run after the document is fully loaded.
        try {
            const mainHeading = document.querySelector('h1');
            if (mainHeading) {
                mainHeading.textContent = 'JS IS RUNNING!';
            } else {
                console.error('H1 element not found for JS test.');
            }
        } catch (e) {
            console.error('Error in basic JS execution test: ', e);
        }
    });

    // UI Elements & Event Listeners specific to index.html
    // Note: canvas, ctx, box, rows, cols are already defined in the script block above.
    const bgMusic = document.getElementById("bgMusic");
    const playPauseBtn = document.getElementById("playPauseBtn");
    const difficultyButtons = document.querySelectorAll(".difficulty-btn");
    const controlBtn = document.getElementById("controlBtn"); // Updated ID
    // const scoreDisplay = document.getElementById("scoreDisplay"); // Replaced by p1CurrentLengthDisplay etc.
    const toggleRulesBtn = document.getElementById('toggleRulesBtn');
    const rulesContainer = document.getElementById('rulesContainer');

    let selectedGameMode = '1P'; // Default to '1P' as it's checked in HTML

    function updateControlBtnText() {
        // Assumes controlBtn, gameStarted, gameOver, isPaused are accessible (gameOver is master)
        if (!gameStarted) {
            controlBtn.textContent = 'Start Game';
        } else if (gameOver) { // Master game over
            controlBtn.textContent = 'Restart Game';
        } else if (isPaused) {
            controlBtn.textContent = 'Resume Game';
        } else {
            controlBtn.textContent = 'Pause Game';
        }
    }

    // Initialize food and draw initial game screen (start message)
    // food.js and game.js functions are now globally available.
    document.addEventListener('DOMContentLoaded', () => {
      try {
        console.log("[DEBUG_STARTUP] index.html: DOMContentLoaded: Initial drawGame call preparing to show start screen.");
        drawGame(); // Call from game.js to draw the initial "Press Start Game" screen.
        updateControlBtnText(); // Set initial text for controlBtn
        updateGameStatusDisplay(); // Initialize P1/P2 status displays

        // Populate Rules
        if (rulesContainer && typeof maxRoundsPerGame !== 'undefined' && typeof maxFoodPerRound !== 'undefined') {
            rulesContainer.innerHTML = `
            <h2>Welcome to Snake!</h2>

            <h3>Game Mode: Two-Player Target Length</h3>
            <p>Compete with a friend or play cooperatively! Each player controls their own snake and tries to complete <strong>${maxRoundsPerGame} rounds</strong>. In each round, players must grow their snake to a randomly assigned target length by eating food. Each player has a limit of <strong>${maxFoodPerRound}</strong> food items per round to reach their target. Your snake's current length is your primary score for the round.</p>

            <h3>Controls:</h3>
            <ul>
                <li><strong>Player 1 (Green Snake):</strong>
                    <ul>
                        <li>Arrow Keys (Up, Down, Left, Right): Control snake direction.</li>
                    </ul>
                </li>
                <li><strong>Player 2 (Blue Snake):</strong>
                    <ul>
                        <li>W, A, S, D Keys: Control snake direction (W=Up, A=Left, S=Down, D=Right).</li>
                    </ul>
                </li>
                <li><strong>Shared Controls (All Players):</strong>
                    <ul>
                        <li>Spacebar: Pause / Resume game for all players.</li>
                        <li>Double-Tap (Mobile): Pause / Resume game for all players. If game is over or not started, it will Start/Restart.</li>
                        <li>Main Control Button (below game): Context-sensitive Pause/Resume/Restart.</li>
                    </ul>
                </li>
            </ul>

            <h3>Two-Player Mode Details:</h3>
            <ul>
                <li><strong>Objective:</strong> Each player independently aims to complete ${maxRoundsPerGame} rounds by reaching their target length within the ${maxFoodPerRound} food item limit per round.</li>
                <li><strong>Food:</strong> Food items are shared. The first snake to reach a food item consumes it, and its effects apply only to that snake. All food on screen refreshes after any food is eaten.</li>
                <li><strong>Collisions:</strong>
                    <ul>
                        <li>Hitting a wall or your <em>own</em> snake's body will result in a game over for that player.</li>
                        <li><strong>Snake vs. Snake:</strong>
                            <ul>
                                <li>If Player 1's head hits Player 2's body, Player 1 is out.</li>
                                <li>If Player 2's head hits Player 1's body, Player 2 is out.</li>
                                <li>If Player 1's head hits Player 2's head (head-on collision), both players are out.</li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li><strong>Game End:</strong>
                    <ul>
                        <li>A player is 'out' if they hit something, fail to meet their target length before running out of food for the round, or are eliminated by the other player.</li>
                        <li>The game session ends when both players are out. The game will then declare a winner based on rounds completed or other criteria if applicable.</li>
                        <li>If one player completes all their rounds and the other is still playing, the game continues for the active player until they also complete their rounds or are out.</li>
                    </ul>
                </li>
                <li><strong>Winning:</strong> Try to complete all your rounds! If both players are active, the one who completes their rounds first or lasts longer with more rounds/length is generally considered the winner.</li>
            </ul>

            <h3>Player Status Displays:</h3>
            <p>Each player has their own status display showing their "Current Length", "Target Length" for the round, "Food This Round" (eaten/max), and "Rounds Cleared". A "GAME OVER" message will appear if a player is out.</p>

            <h3>Difficulty Levels:</h3>
            <p>Choose from Easy, Medium, or Hard before starting or during gameplay. Higher difficulty means a faster snake!</p>

            <h3>Food Types & Effects:</h3>
            <ul>
                <li><strong>Regular Food:</strong> Snake grows by one segment.</li>
                <li><strong>Apple (Yellow):</strong> Snake temporarily changes color. (Traditional score: +5).</li>
                <li><strong>Banana (Orange):</strong> Temporary speed boost. (Traditional score: +2).</li>
                <li><strong>Obstacle (Gray):</strong> Game Over for the player who eats it!</li>
                <li><strong>Red Block (Dark Red):</strong> Doubles current length. Eat 2 consecutively for width increase (max width still applies). (Traditional score: +2).</li>
                <li><strong>Green Block (Dark Green):</strong> Halves current length (if > 2 segments). (Traditional score: +2).</li>
            </ul>

            <p>Have fun playing together!</p>
        `; // Removed "External Button" section as it's not implemented yet.
        } else {
            console.error("Error populating rules: rulesContainer or global game parameters (maxRoundsPerGame, maxFoodPerRound) not found.");
        }

        // Rules Toggle Button Listener
        if (toggleRulesBtn && rulesContainer) {
            toggleRulesBtn.addEventListener('click', () => {
                try { // Inner try-catch for the callback logic
                    if (rulesContainer.style.display === 'none' || rulesContainer.style.display === '') {
                        rulesContainer.style.display = 'block';
                        toggleRulesBtn.textContent = 'Hide Rules';
                    } else {
                        rulesContainer.style.display = 'none';
                        toggleRulesBtn.textContent = 'Show Rules';
                    }
                } catch (e) {
                    console.error("Error in toggleRulesBtn click callback:", e);
                }
            });

            // Update button text based on initial rules visibility
            try { // Inner try-catch for this specific logic
                if (rulesContainer.style.display === 'block') {
                    toggleRulesBtn.textContent = 'Hide Rules';
                } else {
                    toggleRulesBtn.textContent = 'Show Rules';
                }
            } catch (e) {
                console.error("Error setting initial toggleRulesBtn text:", e);
            }
        } else {
            console.error("toggleRulesBtn or rulesContainer not found for event listener attachment or initial text setting.");
        }
      } catch (e) {
        console.error("Error in main DOMContentLoaded setup:", e);
      }
    });

    // Event Listener for the new controlBtn (replaces old startGameBtn listener)
    try {
        if (controlBtn) {
            controlBtn.addEventListener('click', function() {
                try { // Inner try-catch for the callback logic
                    if (!gameStarted) {
                        // Get selected player mode
                        const selectedModeInput = document.querySelector('input[name="playerMode"]:checked');
                        if (selectedModeInput) {
                            selectedGameMode = selectedModeInput.value;
                        }
                        console.log("Selected game mode:", selectedGameMode);

                        // Hide player mode selection UI
                        const playerModeSelectionUI = document.getElementById('playerModeSelection');
                        if (playerModeSelectionUI) {
                            playerModeSelectionUI.style.display = 'none';
                        }

                        // Show main game UI elements
                        const p1Status = document.getElementById('p1StatusContainer');
                        if (p1Status) p1Status.style.display = 'block';

                        // P2 container visibility will be handled by initGame based on selectedGameMode,
                        // but we can make it 'block' here initially, and initGame can hide it if 1P.
                        const p2Status = document.getElementById('p2StatusContainer');
                        if (p2Status) p2Status.style.display = 'block'; // Visibility also managed by updateGameStatusDisplay

                        const gameCanvas = document.getElementById('game');
                        if (gameCanvas) gameCanvas.style.display = 'block';

                        const buttonsDiv = document.querySelector('.buttons');
                        if (buttonsDiv) {
                            buttonsDiv.style.display = 'flex'; // Make the main buttons container visible

                            // Show specific buttons that were hidden individually
                            const toggleRulesBtnElem = document.getElementById('toggleRulesBtn');
                            if (toggleRulesBtnElem) toggleRulesBtnElem.style.display = 'inline-block';

                            const playPauseBtnElem = document.getElementById('playPauseBtn');
                            if (playPauseBtnElem) {
                                playPauseBtnElem.style.display = 'inline-block';
                                const musicNoteSpan = playPauseBtnElem.nextElementSibling;
                                if (musicNoteSpan && musicNoteSpan.tagName === 'SPAN') {
                                    musicNoteSpan.style.display = 'inline';
                                }
                            }

                            // Show direction buttons (select by onclick attribute content - fragile but necessary without better selectors)
                            const allButtonsInContainer = buttonsDiv.querySelectorAll('button.btn');
                            allButtonsInContainer.forEach(btn => {
                                const onclickAttr = btn.getAttribute('onclick');
                                if (onclickAttr && onclickAttr.startsWith("setDirection(")) {
                                    btn.style.display = 'inline-block';
                                }
                            });
                        }

                        const rulesDiv = document.getElementById('rulesContainer');
                        // Rules container visibility is handled by its own toggle button,
                        // but we ensure it's 'block' initially when game starts,
                        // then user can toggle. Or 'none' if toggleRulesBtn should be the only way to show it.
                        // For now, let's make it block, consistent with other elements.
                        if (rulesDiv) rulesDiv.style.display = 'block';

                        initGame(); // from game.js - this will also handle P2 UI based on selectedGameMode
                        if (difficultyButtons) difficultyButtons.forEach(btn => btn.style.display = 'inline-block'); // Show difficulty buttons
                    } else if (gameOver) {
                        // On restart, player mode selection should reappear.
                        const playerModeSelectionUI = document.getElementById('playerModeSelection');
                        if (playerModeSelectionUI) {
                            playerModeSelectionUI.style.display = 'block'; // Show mode selection
                        }
                        // Hide game elements again until mode is re-selected and game started
                        const p1Status = document.getElementById('p1StatusContainer');
                        if (p1Status) p1Status.style.display = 'none';
                        const p2Status = document.getElementById('p2StatusContainer');
                        if (p2Status) p2Status.style.display = 'none';
                        const gameCanvas = document.getElementById('game');
                        if (gameCanvas) gameCanvas.style.display = 'none';
                        const buttonsDiv = document.querySelector('.buttons');
                        if (buttonsDiv) buttonsDiv.style.display = 'none';
                        const rulesDiv = document.getElementById('rulesContainer');
                        if (rulesDiv) rulesDiv.style.display = 'none';

                        // initGame(); // from game.js - NO, initGame is called when Start is pressed again after mode selection
                        // Instead, we need to reset gameStarted, gameOver flags and update button text
                        gameStarted = false;
                        gameOver = false; // Reset master game over
                        p1_gameOver = false; // Reset player-specific game over
                        p2_gameOver = false; // Reset player-specific game over
                        updateControlBtnText(); // Should now say "Start Game"
                        drawGame(); // Show the "Press Start Game" message
                        // Difficulty buttons should be hidden again.
                        if (difficultyButtons) difficultyButtons.forEach(btn => btn.style.display = 'none');

                    // The redundant "else if (gameOver)" block that was here has been removed.
                    } else {
                        togglePauseGame(); // from game.js
                    }
                    // updateControlBtnText() is called by initGame/togglePauseGame in game.js
                } catch (e) {
                    console.error("Error in controlBtn click callback:", e);
                }
            });
        } else {
            console.error("controlBtn not found for event listener attachment.");
        }
    } catch (e) {
        console.error("Error attaching event listener for controlBtn:", e);
    }

    // Event Listener for Keyboard Controls
    try {
        document.addEventListener("keydown", e => {
            try { // Inner try-catch for the callback logic
                if (e.key === " ") {
                    togglePauseGame();
                    e.preventDefault();
                } else if (gameStarted && !isPaused) {
                    // Player 1 Controls (Arrow Keys)
                    if (e.key === "ArrowUp") { changeDirectionP1('up'); }
                    else if (e.key === "ArrowDown") { changeDirectionP1('down'); }
                    else if (e.key === "ArrowLeft") { changeDirectionP1('left'); }
                    else if (e.key === "ArrowRight") { changeDirectionP1('right'); }

                    // Player 2 Controls (WASD) - Conditional on isPlayer2Active
                    else if (typeof isPlayer2Active !== 'undefined' && isPlayer2Active && e.key.toLowerCase() === 'w' && !p2_gameOver) { changeDirectionP2('up'); }
                    else if (typeof isPlayer2Active !== 'undefined' && isPlayer2Active && e.key.toLowerCase() === 's' && !p2_gameOver) { changeDirectionP2('down'); }
                    else if (typeof isPlayer2Active !== 'undefined' && isPlayer2Active && e.key.toLowerCase() === 'a' && !p2_gameOver) { changeDirectionP2('left'); }
                    else if (typeof isPlayer2Active !== 'undefined' && isPlayer2Active && e.key.toLowerCase() === 'd' && !p2_gameOver) { changeDirectionP2('right'); }
                }
            } catch (er) { // Changed 'e' to 'er' to avoid conflict with event 'e'
                console.error("Error in keydown event callback:", er);
            }
        });
    } catch (e) {
        console.error("Error attaching keydown event listener for document:", e);
    }

    // Event Listener for Touchscreen Direction Buttons (Player 1 only for now)
    // This function is called by onclick attributes in HTML
    function setDirection(direction) { // This controls P1 by default
      try {
        if (gameStarted && !isPaused && !p1_gameOver) {
          changeDirectionP1(direction);
        }
      } catch (e) {
        console.error("Error in setDirection function:", e);
      }
    }

    // Event Listeners for Difficulty Buttons
    try {
        if (difficultyButtons) {
            difficultyButtons.forEach(button => {
                if (button) {
                    button.addEventListener("click", () => {
                        try { // Inner try-catch for the callback logic
                            setGameDifficulty(button.dataset.level); // from game.js
                        } catch (e) {
                            console.error("Error in difficulty button click callback:", e);
                        }
                    });
                } else {
                    console.error("A difficulty button element was not found during forEach loop.");
                }
            });
        } else {
            console.error("difficultyButtons NodeList not found for event listener attachment.");
        }
    } catch (e) {
        console.error("Error attaching event listeners for difficultyButtons:", e);
    }

    // Music Play/Pause Button
    try {
        if (playPauseBtn && bgMusic) {
            playPauseBtn.addEventListener("click", () => {
                try { // Inner try-catch for the callback logic
                    if (bgMusic.paused) {
                        bgMusic.play();
                        playPauseBtn.textContent = "Pause Music";
                    } else {
                        bgMusic.pause();
                        playPauseBtn.textContent = "Play Music";
                    }
                } catch (e) {
                    console.error("Error in playPauseBtn click callback:", e);
                }
            });
        } else {
            console.error("playPauseBtn or bgMusic not found for event listener attachment.");
        }
    } catch (e) {
        console.error("Error attaching event listener for playPauseBtn:", e);
    }

    // Current Time Display
    function updateTime() {
      // It's good practice to check if currentTimeDisplay exists within the function
      // especially if it's called by setInterval and the element might disappear.
      try {
        if (currentTimeDisplay) {
          const now = new Date();
          const hours = String(now.getHours()).padStart(2, '0');
          const minutes = String(now.getMinutes()).padStart(2, '0');
          const seconds = String(now.getSeconds()).padStart(2, '0');
          currentTimeDisplay.innerHTML = `${hours}:${minutes}:${seconds}`;
        }
      } catch (e) {
        console.error("Error in updateTime function body:", e);
        // Optionally, could clear interval here if error is persistent
      }
    }

    try {
        // updateTime is called immediately and then via setInterval
        if (typeof currentTimeDisplay !== 'undefined' && currentTimeDisplay) { // Check if currentTimeDisplay exists
             updateTime(); // Initial call
             setInterval(updateTime, 1000); // Update every second
        } else {
            console.error("currentTimeDisplay element not found for time updates.");
        }
    } catch (e) {
        console.error("Error in initial time update or setInterval setup:", e);
    }

    // Swipe Controls for Mobile
    let touchStartX = 0;
    let touchStartY = 0;
    let touchEndX = 0;
    let touchEndY = 0;
    const minSwipeDistance = 30; // Minimum distance for a swipe to be registered
    let lastTapTime = 0;
    const doubleTapDelay = 300; // Milliseconds
    const tapThreshold = 10; // Max pixels to move for it to be considered a tap

    try {
        // Check if canvas exists (it should, given earlier checks, but good practice for standalone blocks)
        if (canvas) {
            canvas.addEventListener('touchstart', function(e) {
                try {
                    touchStartX = e.touches[0].clientX;
                    touchStartY = e.touches[0].clientY;
                } catch (er) { console.error("Error in touchstart callback:", er); }
            }, false);

            canvas.addEventListener('touchmove', function(e) {
                // Minimal logic, direct error less likely here unless e.touches is problematic
                // For complex logic, a try-catch would be good.
            }, false);

            canvas.addEventListener('touchend', function(e) {
                try {
                    touchEndX = e.changedTouches[0].clientX;
                    touchEndY = e.changedTouches[0].clientY;

                    const diffX = touchEndX - touchStartX;
                    const diffY = touchEndY - touchStartY;
                    const currentTime = new Date().getTime();
                    const tapTimeDifference = currentTime - lastTapTime;

                    if (Math.abs(diffX) < tapThreshold && Math.abs(diffY) < tapThreshold) {
                        e.preventDefault();
                        if (tapTimeDifference < doubleTapDelay && tapTimeDifference > 0) {
                            if (gameStarted && !gameOver) {
                                togglePauseGame();
                            } else {
                                const startGameButton = document.getElementById('startGameBtn'); // This ID might be legacy
                                if(startGameButton) startGameButton.style.display = 'none';
                                if (difficultyButtons) difficultyButtons.forEach(btn => btn.style.display = 'inline-block');
                                initGame();
                            }
                            lastTapTime = 0;
                        } else {
                            lastTapTime = currentTime;
                        }
                    } else {
                        if (!gameStarted || isPaused) return;

                        if (Math.abs(diffX) > Math.abs(diffY)) {
                            if (diffX > minSwipeDistance) { changeDirection('right'); }
                            else if (diffX < -minSwipeDistance) { changeDirection('left'); }
                        } else if (Math.abs(diffY) > Math.abs(diffX)) {
                            if (diffY > minSwipeDistance) { changeDirection('down'); }
                            else if (diffY < -minSwipeDistance) { changeDirection('up'); }
                        }
                    }
                } catch (er) { console.error("Error in touchend callback:", er); }
            }, false);

            // Canvas click/tap to start game (also on canvas)
            canvas.addEventListener('click', function() {
                try {
                    if (!gameStarted) {
                        initGame();
                        if (difficultyButtons) difficultyButtons.forEach(btn => btn.style.display = 'inline-block');
                    }
                } catch (er) { console.error("Error in canvas click callback:", er); }
            });
        } else {
            console.error("Canvas element not found for touch/click event listener attachment.");
        }
    } catch (e) {
        console.error("Error attaching touch/click event listeners for canvas:", e);
    }

    // Ensure difficulty buttons are hidden initially, shown by initGame
    // This should be done once, perhaps after defining difficultyButtons or in DOMContentLoaded
    // For safety, let's ensure they are hidden on script load if not already by HTML.
    // However, the HTML already sets them to display:none. This line is redundant but harmless.
    // difficultyButtons.forEach(btn => btn.style.display = 'none');


  </script>
</body>
</html>
