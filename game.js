// game.js

// Assumes food.js and snake.js are loaded first.
// Assumes canvas, ctx, box, rows, snake (array from snake.js) are global.
// Assumes activeFoods (array from food.js) is global.
// Assumes all necessary functions from snake.js (applyTransformation, resetSnake, moveSnake,
// checkWallCollision, checkSelfCollision, incrementConsecutiveRedBlocks,
// resetConsecutiveRedBlocks, getConsecutiveRedBlocks, incrementSnakeWidth) are global.

// Game state variables
let score = 0; // Traditional score, will be repurposed or less prominent
let gameOver = false;
let isPaused = false;
let gameStarted = false;
let gameSpeed = 200; // Default to Easy speed
let gameIntervalId;

// New state variables for Target Length mode
let targetLength = 0; // Will be set at the start of each round
let roundsAchieved = 0;
const maxRoundsPerGame = 5; // Example, can be adjusted
let foodEatenThisRound = 0;
const maxFoodPerRound = 10; // Example, can be adjusted


// Variables for speed boost effect
let originalGameSpeed = 0;
let speedBoostTimeoutId = null;

/**
 * Updates the score display in the HTML.
 * For Target Length mode, this will now update all game status displays.
 */
function updateGameStatusDisplay() {
    const targetLengthEl = document.getElementById('targetLengthDisplay');
    const roundsEl = document.getElementById('roundsDisplay');
    const foodThisRoundEl = document.getElementById('foodThisRoundDisplay');
    const currentLengthEl = document.getElementById('scoreDisplay'); // Repurposed for current length

    if (targetLengthEl) {
        targetLengthEl.textContent = 'Target Length: ' + targetLength;
    }
    if (roundsEl) {
        roundsEl.textContent = 'Rounds Cleared: ' + roundsAchieved + ' / ' + maxRoundsPerGame;
    }
    if (foodThisRoundEl) {
        foodThisRoundEl.textContent = 'Food This Round: ' + foodEatenThisRound + ' / ' + maxFoodPerRound;
    }
    if (currentLengthEl) {
        // Assuming 'snake' array is globally accessible from snake.js
        currentLengthEl.textContent = 'Current Length: ' + (typeof snake !== 'undefined' ? snake.length : 0);
    }
    // Traditional score can be hidden or shown elsewhere if needed, for now it's replaced by current length.
}


/**
 * Initializes or resets the game state for a new game.
 */
function initGame() {
    gameStarted = true;
    isPaused = false;
    gameOver = false;
    score = 0; // Reset traditional score (though less prominent now)

    // Initialize Target Length mode variables
    targetLength = 0; // Will be set by startNewRound() or similar logic later
    roundsAchieved = 0;
    foodEatenThisRound = 0;
    // Call new display update function
    // updateGameStatusDisplay(); // Called after startNewRound

    if (speedBoostTimeoutId) {
        clearTimeout(speedBoostTimeoutId);
        speedBoostTimeoutId = null;
    }
    gameSpeed = 200;

    resetSnake(); // From snake.js - also resets width and consecutive red blocks
    // generateNewFood(); // Food is generated by startNewRound
    startNewRound(); // Initialize first round (sets targetLength, foodEatenThisRound, calls generateNewFood)

    // updateGameStatusDisplay(); // Called by startNewRound

    if (gameIntervalId) {
        clearInterval(gameIntervalId);
    }
    gameIntervalId = setInterval(updateGame, gameSpeed);

    drawGame(); // drawGame will also call updateGameStatusDisplay
    if (typeof updateControlBtnText === 'function') updateControlBtnText();
}


function startNewRound() {
    foodEatenThisRound = 0;
    // Calculate targetLength: current snake length + random(3 to 7)
    let currentSnakeLength = (typeof snake !== 'undefined' && snake.length > 0) ? snake.length : 1;
    targetLength = currentSnakeLength + Math.floor(Math.random() * 5) + 3;

    console.log("[GAME LOGIC] New Round Started. Target Length: " + targetLength + ", Current Snake Length: " + currentSnakeLength + ", Food this round: " + foodEatenThisRound);
    generateNewFood(); // Generate food for the new round
    updateGameStatusDisplay(); // Update UI
}

/**
 * Main game drawing function.
 */
function drawGame() {
    if (!ctx || !canvas) return;

    if (!gameStarted) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#fff";
        ctx.font = "30px Arial";
        ctx.textAlign = "center";
        ctx.fillText("Press Start Game", canvas.width / 2, canvas.height / 2);
        updateGameStatusDisplay(); // Use new display function
        return;
    }

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawFood();
    drawSnake();
    updateGameStatusDisplay(); // Use new display function

    if (isPaused) {
        ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#fff";
        ctx.font = "30px Arial";
        ctx.textAlign = "center";
        ctx.fillText("Paused", canvas.width / 2, canvas.height / 2);
    }
}

/**
 * Main game update function.
 */
function updateGame() {
    if (gameOver) {
        // triggerEndGame handles alert and reload
        // No direct alert/reload here to allow triggerEndGame to use isWin parameter
        return;
    }

    if (isPaused) {
        drawGame();
        return;
    }

    const head = moveSnake();

    // Pass 'rows' for cols and rows as checkWallCollision expects it (from snake.js context)
    if (checkWallCollision(head) || checkSelfCollision(head)) { // Assuming checkWallCollision now uses 'rows' for cols too
        triggerEndGame();
        return;
    }

    let foodEatenThisTick = false;
    const eatenFoodItem = checkFoodEaten(head);

    if (eatenFoodItem) {
        foodEatenThisTick = true;
        const eatenFoodType = eatenFoodItem.type;
        score += eatenFoodType.score;


        // Fattening logic
        if (eatenFoodType.id === FOOD_TYPES.RED_BLOCK.id) { // Check against ID from FOOD_TYPES
            console.log("[DEBUG][game.js] RED_BLOCK eaten. Consecutive (before inc): " + getConsecutiveRedBlocks() + ", current snakeWidth: " + getSnakeWidth());
            incrementConsecutiveRedBlocks(); // from snake.js
            console.log("[DEBUG][game.js] Consecutive (after inc): " + getConsecutiveRedBlocks());
            if (getConsecutiveRedBlocks() >= 2) {
                console.log("[DEBUG][game.js] Consecutive >= 2. Calling incrementSnakeWidth. snakeWidth (before inc): " + getSnakeWidth());
                incrementSnakeWidth(); // from snake.js
                console.log("[DEBUG][game.js] snakeWidth (after inc): " + getSnakeWidth());
                resetConsecutiveRedBlocks(); // from snake.js
                console.log("[DEBUG][game.js] Resetting consecutive count after width increment. Count: " + getConsecutiveRedBlocks());

                // NEW: Check for game over due to excessive width
                // This check is REMOVED as per subtask instructions.
                // if (getSnakeWidth() > 2) {
                //     console.log("[GAME OVER] Snake width exceeded 2! Width: " + getSnakeWidth());
                //     triggerEndGame(false);
                //     return;
                // }
            }
        } else {
            // Only reset if it's not a RED_BLOCK. If it was a RED_BLOCK but count < 2, we don't reset here.
            // The reset for RED_BLOCK happens above if width is incremented.
            // This else means "any food other than RED_BLOCK was eaten".
            console.log("[DEBUG][game.js] Non-RED_BLOCK eaten. Resetting consecutive count. Consecutive (before reset): " + getConsecutiveRedBlocks());
            resetConsecutiveRedBlocks(); // from snake.js, reset if other food eaten
        }

        if (eatenFoodType.effect === 'game_over') {
            triggerEndGame(false); // Explicitly lost
            drawGame();
            return;
        }

        if (eatenFoodType.effect === 'speed_boost') {
            if (speedBoostTimeoutId) {
                clearTimeout(speedBoostTimeoutId);
            } else {
                originalGameSpeed = gameSpeed;
            }
            if (originalGameSpeed === 0) originalGameSpeed = gameSpeed;

            gameSpeed = Math.max(50, Math.floor(originalGameSpeed * eatenFoodType.speedMultiplier));

            clearInterval(gameIntervalId);
            gameIntervalId = setInterval(updateGame, gameSpeed);

            speedBoostTimeoutId = setTimeout(() => {
                gameSpeed = originalGameSpeed;
                if (gameStarted && !gameOver && !isPaused) {
                    clearInterval(gameIntervalId);
                    gameIntervalId = setInterval(updateGame, gameSpeed);
                }
                speedBoostTimeoutId = null;
                originalGameSpeed = 0;
            }, eatenFoodType.duration);
        }

        if (eatenFoodType.transform) {
            applyTransformation(eatenFoodType.transform);
        }

        if (eatenFoodType.effect === 'double_length') {
            const segmentsToAdd = snake.length;
            for (let i = 0; i < segmentsToAdd; i++) {
                snake.push({ x: snake[snake.length - 1].x, y: snake[snake.length - 1].y });
            }
        } else if (eatenFoodType.effect === 'halve_length') {
            const lenForHalvingCheck = snake.length;
            if (lenForHalvingCheck > 2) {
                const targetLength = Math.max(1, Math.floor(lenForHalvingCheck / 2));
                while (snake.length > targetLength) {
                    if (snake.length > 1) snake.pop();
                    else break;
                }
            }
        }

        // Target Length Mode Logic: After all other effects of eating one food item
        foodEatenThisRound++;
        updateGameStatusDisplay(); // Update UI for food eaten count

        if (snake.length >= targetLength) {
            roundsAchieved++;
            console.log("[GAME LOGIC] Target Reached! Rounds Achieved: " + roundsAchieved + ". Snake Length: " + snake.length);
            updateGameStatusDisplay(); // Update rounds display
            if (roundsAchieved >= maxRoundsPerGame) {
                triggerEndGame(true); // Game Won!
                return;
            } else {
                startNewRound(); // Start next round (this will call generateNewFood)
            }
        } else if (foodEatenThisRound >= maxFoodPerRound) {
            console.log("[GAME LOGIC] Out of food for this round! Game Over. Food eaten: " + foodEatenThisRound + ", Target Length: " + targetLength + ", Snake Length: " + snake.length);
            triggerEndGame(false); // Game Over - target not met due to food limit
            return;
        }
        // If neither round win nor food limit game over, just generate new food (already called if single food source)
        // With multiple foods, generateNewFood is called after any food is eaten to refresh the set.
        generateNewFood(); // Refresh food supply
    }

    if (!foodEatenThisTick) {
        if (snake.length > 1) {
             snake.pop();
        }
    }

    drawGame();
}

/**
 * Sets gameOver flag and clears speed boost.
 * @param {boolean} isWin - True if the game was won, false otherwise (or undefined for standard game over).
 */
function triggerEndGame(isWin) {
    gameOver = true;
    if (speedBoostTimeoutId) {
        clearTimeout(speedBoostTimeoutId);
        speedBoostTimeoutId = null;
    }

    // Stop the game loop immediately
    clearInterval(gameIntervalId);

    // Update UI before alert
    if (typeof updateControlBtnText === 'function') updateControlBtnText();
    if (typeof updateGameStatusDisplay === 'function') updateGameStatusDisplay(); // Ensure final stats are shown
    drawGame(); // Draw final game state before alert

    let endMessage;
    if (isWin === true) { // Explicitly check for true
        endMessage = "Congratulations! You Reached All Targets!";
    } else if (isWin === false) { // Explicitly check for false (lost Target Length mode)
         if (foodEatenThisRound >= maxFoodPerRound && snake.length < targetLength) {
            endMessage = "Target Not Reached: Ran out of food for the round! Game Over.";
        } else if (getSnakeWidth() > 2 && isWin === false) { // Check if game over was due to width if isWin is false
             // This specific message for "too wide" might be redundant if the primary trigger is removed
             // and other conditions (like wall collision for a wide snake) cause a generic game over.
             // For now, keeping it to show the game *could* have known it was too wide if that logic was active.
             // However, since the trigger for width > 2 causing game over is removed from updateGame,
             // this specific message in triggerEndGame might not be hit for that reason anymore.
             // It would only be hit if triggerEndGame(false) was called *after* width became > 2 for some other reason.
             // Let's simplify the message logic in triggerEndGame for now.
             endMessage = "Game Over: Snake too wide!"; // This might become an orphaned message if not triggered.
        }
         else {
            endMessage = "Target Not Reached! Game Over.";
        }
    } else { // Standard game over (wall collision, self-collision, obstacle)
        endMessage = "游戏结束！"; // Original Chinese message for standard game over
    }

    // The old alert was: alert("游戏结束！你的得分：" + score);
    // New alert includes snake length as the primary "score" for this mode.
    alert(endMessage + " Final Length: " + snake.length + " (Rounds: " + roundsAchieved + "/" + maxRoundsPerGame + ")");
    location.reload(); // Reloads the page to reset to start screen
}

/**
 * Sets the game difficulty (speed).
 */
function setGameDifficulty(level) {
    let newSpeed;
    switch (level) {
        case 'easy': newSpeed = 200; break;
        case 'medium': newSpeed = 150; break;
        case 'hard': newSpeed = 100; break;
        default: newSpeed = gameSpeed;
    }

    if (speedBoostTimeoutId && originalGameSpeed > 0) {
        originalGameSpeed = newSpeed;
    } else {
         gameSpeed = newSpeed;
    }

    if (gameStarted && !gameOver && !isPaused) {
        clearInterval(gameIntervalId);
        gameIntervalId = setInterval(updateGame, gameSpeed);
    }
}

/**
 * Toggles the pause state of the game.
 */
function togglePauseGame() {
    if (!gameStarted || gameOver) {
        return;
    }
    isPaused = !isPaused;
    if (isPaused) {
        drawGame();
    } else {
        clearInterval(gameIntervalId);
        gameIntervalId = setInterval(updateGame, gameSpeed);
    }
    if (typeof updateControlBtnText === 'function') updateControlBtnText();
}
